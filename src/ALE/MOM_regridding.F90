!> Generates vertical grids as part of the ALE algorithm
module MOM_regridding

! This file is part of MOM6. See LICENSE.md for the license.

use MOM_error_handler, only : MOM_error, FATAL, WARNING
use MOM_file_parser,   only : param_file_type, get_param, log_param
use MOM_io,            only : file_exists, field_exists, field_size, MOM_read_data
use MOM_io,            only : vardesc, var_desc, fieldtype, SINGLE_FILE
use MOM_io,            only : create_file, write_field, close_file, slasher
use MOM_variables,     only : ocean_grid_type, thermo_var_ptrs
use MOM_verticalGrid,  only : verticalGrid_type
use MOM_EOS,           only : EOS_type, calculate_density, calculate_density_derivs
use MOM_string_functions,only : uppercase, extractWord, extract_integer, extract_real

use MOM_remapping, only : remapping_CS
use regrid_consts, only : state_dependent, coordinateUnits
use regrid_consts, only : coordinateMode, DEFAULT_COORDINATE_MODE
use regrid_consts, only : REGRIDDING_LAYER, REGRIDDING_ZSTAR
use regrid_consts, only : REGRIDDING_RHO, REGRIDDING_SIGMA
use regrid_consts, only : REGRIDDING_ARBITRARY, REGRIDDING_SIGMA_SHELF_ZSTAR
use regrid_consts, only : REGRIDDING_HYCOM1, REGRIDDING_SLIGHT, REGRIDDING_ADAPTIVE
use regrid_interp, only : interp_CS_type, set_interp_scheme, set_interp_extrap

use coord_zlike,  only : init_coord_zlike, zlike_CS, set_zlike_params, build_zstar_column, end_coord_zlike
use coord_sigma,  only : init_coord_sigma, sigma_CS, set_sigma_params, build_sigma_column, end_coord_sigma
use coord_rho,    only : init_coord_rho, rho_CS, set_rho_params, build_rho_column, end_coord_rho
use coord_rho,    only : old_inflate_layers_1d
use coord_hycom,  only : init_coord_hycom, hycom_CS, set_hycom_params, build_hycom1_column, end_coord_hycom
use coord_slight, only : init_coord_slight, slight_CS, set_slight_params, build_slight_column, end_coord_slight
use coord_adapt,  only : init_coord_adapt, adapt_CS, set_adapt_params, build_adapt_column, end_coord_adapt

use coord_adapt, only : adapt_diag_CS

use netcdf ! Used by check_grid_def()

implicit none ; private

#include <MOM_memory.h>

!> Regridding control structure
type, public :: regridding_CS
  private

  !> This array is set by function setCoordinateResolution()
  !! It contains the "resolution" or delta coordinate of the target
  !! coorindate. It has the units of the target coordiante, e.g.
  !! meters for z*, non-dimensional for sigma, etc.
  real, dimension(:), allocatable :: coordinateResolution

  !> This array is set by function set_target_densities()
  !! This array is the nominal coordinate of interfaces and is the
  !! running sum of coordinateResolution. i.e.
  !!  target_density(k+1) = coordinateResolution(k) + coordinateResolution(k)
  !! It is only used in "rho" mode.
  real, dimension(:), allocatable :: target_density
  logical :: target_density_set = .false.

  !> This array is set by function set_regrid_max_depths()
  !! It specifies the maximum depth that every interface is allowed to take, in H.
  real, dimension(:), allocatable :: max_interface_depths

  !> This array is set by function set_regrid_max_thickness()
  !! It specifies the maximum depth that every interface is allowed to take, in H.
  real, dimension(:), allocatable :: max_layer_thickness

  integer :: nk !< Number of layers/levels

  !> Indicates which grid to use in the vertical (z*, sigma, target interface
  !! densities)
  integer :: regridding_scheme

  !> Interpolation control structure
  type(interp_CS_type) :: interp_CS

  !> Minimum thickness allowed when building the new grid through regridding
  real :: min_thickness

  !> Reference pressure for potential density calculations (Pa)
  real :: ref_pressure = 2.e7

  !> Weight given to old coordinate when blending between new and old grids (nondim)
  !! Used only below depth_of_time_filter_shallow, with a cubic variation
  !! from zero to full effect between depth_of_time_filter_shallow and
  !! depth_of_time_filter_deep.
  real :: old_grid_weight = 0.

  !> Depth above which no time-filtering of grid is applied (H units)
  real :: depth_of_time_filter_shallow = 0.

  !> Depth below which time-filtering of grid is applied at full effect (H units)
  real :: depth_of_time_filter_deep = 0.

  !> Fraction (between 0 and 1) of compressibility to add to potential density
  !! profiles when interpolating for target grid positions. (nondim)
  real :: compressibility_fraction = 0.

  !> If true, each interface is given a maximum depth based on a rescaling of
  !! the indexing of coordinateResolution.
  logical :: set_maximum_depths = .false.

  !> A scaling factor (> 1) of the rate at which the coordinateResolution list
  !! is traversed to set the minimum depth of interfaces.
  real :: max_depth_index_scale = 2.0

  !> If true, integrate for interface positions from the top downward.
  !! If false, integrate from the bottom upward, as does the rest of the model.
  logical :: integrate_downward_for_e = .true.

  type(zlike_CS),  pointer :: zlike_CS  => null()
  type(sigma_CS),  pointer :: sigma_CS  => null()
  type(rho_CS),    pointer :: rho_CS    => null()
  type(hycom_CS),  pointer :: hycom_CS  => null()
  type(slight_CS), pointer :: slight_CS => null()
  type(adapt_CS),  pointer :: adapt_CS  => null()

end type

! The following routines are visible to the outside world
public initialize_regridding, end_regridding, regridding_main
public inflate_vanished_layers_old, check_remapping_grid, check_grid_column
public adjust_interface_motion
public set_regrid_params, get_regrid_size
public uniformResolution, setCoordinateResolution
public build_rho_column
public set_target_densities_from_GV, set_target_densities
public set_regrid_max_depths, set_regrid_max_thickness
public getCoordinateResolution, getCoordinateInterfaces
public getCoordinateUnits, getCoordinateShortName, getStaticThickness
public DEFAULT_COORDINATE_MODE
public get_zlike_CS, get_sigma_CS, get_rho_CS

!> Documentation for coordinate options
character(len=*), parameter, public :: regriddingCoordinateModeDoc = &
                 " LAYER - Isopycnal or stacked shallow water layers\n"//&
                 " ZSTAR, Z* - stetched geopotential z*\n"//&
                 " SIGMA_SHELF_ZSTAR - stetched geopotential z* ignoring shelf\n"//&
                 " SIGMA - terrain following coordinates\n"//&
                 " RHO   - continuous isopycnal\n"//&
                 " HYCOM1 - HyCOM-like hybrid coordinate\n"//&
                 " SLIGHT - stretched coordinates above continuous isopycnal\n"//&
                 " ADAPTIVE - optimize for smooth neutral density surfaces"

! Documentation for regridding interpolation schemes
character(len=*), parameter, public :: regriddingInterpSchemeDoc = &
                 " P1M_H2     (2nd-order accurate)\n"//&
                 " P1M_H4     (2nd-order accurate)\n"//&
                 " P1M_IH4    (2nd-order accurate)\n"//&
                 " PLM        (2nd-order accurate)\n"//&
                 " PPM_H4     (3rd-order accurate)\n"//&
                 " PPM_IH4    (3rd-order accurate)\n"//&
                 " P3M_IH4IH3 (4th-order accurate)\n"//&
                 " P3M_IH6IH5 (4th-order accurate)\n"//&
                 " PQM_IH4IH3 (4th-order accurate)\n"//&
                 " PQM_IH6IH5 (5th-order accurate)"
character(len=*), parameter, public :: regriddingDefaultInterpScheme = "P1M_H2"
logical, parameter, public :: regriddingDefaultBoundaryExtrapolation = .false.
real, parameter, public :: regriddingDefaultMinThickness = 1.e-3

contains

!> Initialization and configures a regridding control structure based on customizable run-time parameters
subroutine initialize_regridding(CS, GV, max_depth, param_file, mod, coord_mode, param_prefix, param_suffix)
  type(regridding_CS),        intent(inout) :: CS !< Regridding control structure
  type(verticalGrid_type),    intent(in)    :: GV         !< Ocean vertical grid structure
  real,                       intent(in)    :: max_depth  !< The maximum depth of the ocean, in m.
  type(param_file_type),      intent(in)    :: param_file !< Parameter file
  character(len=*),           intent(in)    :: mod        !< Name of calling module.
  character(len=*),           intent(in)    :: coord_mode !< Coordinate mode
  character(len=*),           intent(in)    :: param_prefix !< String to prefix to parameter names.
                                                            !! If empty, causes main model parameters to be used.
  character(len=*),           intent(in)    :: param_suffix !< String to append to parameter names.
  ! Local variables
  integer :: ke ! Number of levels
  character(len=80)  :: string, string2, varName ! Temporary strings
  character(len=40)  :: coord_units, param_name, coord_res_param ! Temporary strings
  character(len=200) :: inputdir, fileName
  character(len=320) :: message ! Temporary strings
  character(len=12) :: expected_units ! Temporary strings
  logical :: tmpLogical, fix_haloclines, set_max, do_sum, main_parameters
  logical :: coord_is_state_dependent, ierr
  real :: filt_len, strat_tol, index_scale, tmpReal
  real :: dz_fixed_sfc, Rho_avg_depth, nlay_sfc_int
  real :: adaptAlphaRho, adaptAlphaP, adaptKappa, adaptTau
  integer :: nz_fixed_sfc, k, nzf(4)
  real, dimension(:), allocatable :: dz     ! Resolution (thickness) in units of coordinate
  real, dimension(:), allocatable :: h_max  ! Maximum layer thicknesses, in m.
  real, dimension(:), allocatable :: dz_max ! Thicknesses used to find maximum interface depths, in m.
  real, dimension(:), allocatable :: z_max  ! Maximum interface depths, in m.
  real, dimension(:), allocatable :: rho_target ! Target density used in HYBRID mode
  ! Thicknesses that give level centers corresponding to table 2 of WOA09
  real, dimension(40) :: woa09_dz = (/ 5.,  10.,  10.,  15.,  22.5, 25., 25.,  25.,  &
                                      37.5, 50.,  50.,  75., 100., 100., 100., 100., &
                                     100., 100., 100., 100., 100., 100., 100., 175., &
                                     250., 375., 500., 500., 500., 500., 500., 500., &
                                     500., 500., 500., 500., 500., 500., 500., 500. /)

  call get_param(param_file, mod, "INPUTDIR", inputdir, default=".")
  inputdir = slasher(inputdir)

  main_parameters=.false.
  if (len_trim(param_prefix)==0) main_parameters=.true.
  if (main_parameters .and. len_trim(param_suffix)>0) call MOM_error(FATAL,trim(mod)//', initialize_regridding: '// &
              'Suffix provided without prefix for parameter names!')

  CS%nk = 0
  CS%regridding_scheme = coordinateMode(coord_mode)
  coord_is_state_dependent = state_dependent(coord_mode)

  if (main_parameters) then
    ! Read coordinate units parameter (main model = REGRIDDING_COORDINATE_UNITS)
    call get_param(param_file, mod, "REGRIDDING_COORDINATE_UNITS", coord_units, &
                 "Units of the regridding coordinuate.",&
                 default=coordinateUnits(coord_mode))
  else
    coord_units=coordinateUnits(coord_mode)
  endif

  if (coord_is_state_dependent) then
    if (main_parameters) then
      param_name = "INTERPOLATION_SCHEME"
      string2 = regriddingDefaultInterpScheme
    else
      param_name = trim(param_prefix)//"_INTERP_SCHEME_"//trim(param_suffix)
      string2 = 'PPM_H4' ! Default for diagnostics
    endif
    call get_param(param_file, mod, "INTERPOLATION_SCHEME", string, &
                 "This sets the interpolation scheme to use to\n"//&
                 "determine the new grid. These parameters are\n"//&
                 "only relevant when REGRIDDING_COORDINATE_MODE is\n"//&
                 "set to a function of state. Otherwise, it is not\n"//&
                 "used. It can be one of the following schemes:\n"//&
                 trim(regriddingInterpSchemeDoc), default=trim(string2))
    call set_regrid_params(CS, interp_scheme=string)
  endif

  if (main_parameters .and. coord_is_state_dependent) then
    call get_param(param_file, mod, "BOUNDARY_EXTRAPOLATION", tmpLogical, &
                 "When defined, a proper high-order reconstruction\n"//&
                 "scheme is used within boundary cells rather\n"//&
                 "than PCM. E.g., if PPM is used for remapping, a\n"//&
                 "PPM reconstruction will also be used within\n"//&
                 "boundary cells.", default=regriddingDefaultBoundaryExtrapolation)
    call set_regrid_params(CS, boundary_extrapolation=tmpLogical)
  else
    call set_regrid_params(CS, boundary_extrapolation=.false.)
  endif

  ! Read coordinate configuration parameter (main model = ALE_COORDINATE_CONFIG)
  if (main_parameters) then
    param_name = "ALE_COORDINATE_CONFIG"
    coord_res_param = "ALE_RESOLUTION"
    string2 = 'UNIFORM'
  else
    param_name = trim(param_prefix)//"_DEF_"//trim(param_suffix)
    coord_res_param = trim(param_prefix)//"_RES_"//trim(param_suffix)
    string2 = 'UNIFORM'
    if (max_depth>3000.) string2='WOA09' ! For convenience
  endif
  call get_param(param_file, mod, param_name, string, &
                 "Determines how to specify the coordinate\n"//&
                 "resolution. Valid options are:\n"//&
                 " PARAM       - use the vector-parameter "//trim(coord_res_param)//"\n"//&
                 " UNIFORM[:N] - uniformly distributed\n"//&
                 " FILE:string - read from a file. The string specifies\n"//&
                 "               the filename and variable name, separated\n"//&
                 "               by a comma or space, e.g. FILE:lev.nc,dz\n"//&
                 "               or FILE:lev.nc,interfaces=zw\n"//&
                 " WOA09[:N]   - the WOA09 vertical grid (approximately)\n"//&
                 " FNC1:string - FNC1:dz_min,H_total,power,precision\n"//&
                 " HYBRID:string - read from a file. The string specifies\n"//&
                 "               the filename and two variable names, separated\n"//&
                 "               by a comma or space, for sigma-2 and dz. e.g.\n"//&
                 "               HYBRID:vgrid.nc,sigma2,dz",&
                 default=trim(string2))
  message = "The distribution of vertical resolution for the target\n"//&
            "grid used for Eulerian-like coordinates. For example,\n"//&
            "in z-coordinate mode, the parameter is a list of level\n"//&
            "thicknesses (in m). In sigma-coordinate mode, the list\n"//&
            "is of non-dimensional fractions of the water column."
  if (index(trim(string),'UNIFORM')==1) then
    if (len_trim(string)==7) then
      ke = GV%ke ! Use model nk by default
      tmpReal = max_depth
    elseif (index(trim(string),'UNIFORM:')==1 .and. len_trim(string)>8) then
      ! Format is "UNIFORM:N" or "UNIFORM:N,dz"
      ke = extract_integer(string(9:len_trim(string)),'',1)
      tmpReal = extract_real(string(9:len_trim(string)),',',2,missing_value=max_depth)
    else
      call MOM_error(FATAL,trim(mod)//', initialize_regridding: '// &
          'Unable to interpret "'//trim(string)//'".')
    endif
    allocate(dz(ke))
    if (ke==1) then
      dz(:) = uniformResolution(ke, coord_mode, tmpReal, GV%Rlay(1), GV%Rlay(1))
    else
      dz(:) = uniformResolution(ke, coord_mode, tmpReal, &
                   GV%Rlay(1)+0.5*(GV%Rlay(1)-GV%Rlay(2)), &
                   GV%Rlay(ke)+0.5*(GV%Rlay(ke)-GV%Rlay(ke-1)) )
    endif
    if (main_parameters) call log_param(param_file, mod, "!"//coord_res_param, dz, &
                   trim(message), units=trim(coord_units))
  elseif (trim(string)=='PARAM') then
    ! Read coordinate resolution (main model = ALE_RESOLUTION)
    ke = GV%ke ! Use model nk by default
    allocate(dz(ke))
    call get_param(param_file, mod, coord_res_param, dz, &
                   trim(message), units=trim(coord_units), fail_if_missing=.true.)
  elseif (index(trim(string),'FILE:')==1) then
    ! FILE:filename,var_name is assumed to be reading level thickness variables
    ! FILE:filename,interfaces=var_name reads positions
    if (string(6:6)=='.' .or. string(6:6)=='/') then
      ! If we specified "FILE:./xyz" or "FILE:/xyz" then we have a relative or absolute path
      fileName = trim( extractWord(trim(string(6:80)), 1) )
    else
      ! Otherwise assume we should look for the file in INPUTDIR
      fileName = trim(inputdir) // trim( extractWord(trim(string(6:80)), 1) )
    endif
    if (.not. file_exists(fileName)) call MOM_error(FATAL,trim(mod)//", initialize_regridding: "// &
            "Specified file not found: Looking for '"//trim(fileName)//"' ("//trim(string)//")")

    varName = trim( extractWord(trim(string(6:)), 2) )
    if (len_trim(varName)==0) then
      if (field_exists(fileName,'dz')) then; varName = 'dz'
      elseif (field_exists(fileName,'dsigma')) then; varName = 'dsigma'
      elseif (field_exists(fileName,'ztest')) then; varName = 'ztest'
      else ;  call MOM_error(FATAL,trim(mod)//", initialize_regridding: "// &
                    "Coordinate variable not specified and none could be guessed.")
      endif
    endif
    ! This check fails when the variable is a dimension variable! -AJA
   !if (.not. field_exists(fileName,trim(varName))) call MOM_error(FATAL,trim(mod)//", initialize_regridding: "// &
   !             "Specified field not found: Looking for '"//trim(varName)//"' ("//trim(string)//")")
    if (CS%regridding_scheme == REGRIDDING_SIGMA) then
      expected_units = 'nondim'
    elseif (CS%regridding_scheme == REGRIDDING_RHO) then
      expected_units = 'kg m-3'
    else
      expected_units = 'meters'
    endif
    if (index(trim(varName),'interfaces=')==1) then
      varName=trim(varName(12:))
      call check_grid_def(filename, varName, expected_units, message, ierr)
      if (ierr) call MOM_error(FATAL,trim(mod)//", initialize_regridding: "//&
                  "Unsupported format in grid definition '"//trim(filename)//"'. Error message "//trim(message))
      call field_size(trim(fileName), trim(varName), nzf)
      ke = nzf(1)-1
      if (CS%regridding_scheme == REGRIDDING_RHO) then
        allocate(rho_target(ke+1))
        call MOM_read_data(trim(fileName), trim(varName), rho_target)
      else
        allocate(dz(ke))
        allocate(z_max(ke+1))
        call MOM_read_data(trim(fileName), trim(varName), z_max)
        dz(:) = abs(z_max(1:ke) - z_max(2:ke+1))
        deallocate(z_max)
      endif
    else
      ! Assume reading resolution
      call field_size(trim(fileName), trim(varName), nzf)
      ke = nzf(1)
      allocate(dz(ke))
      call MOM_read_data(trim(fileName), trim(varName), dz)
    endif
    if (main_parameters .and. ke/=GV%ke) then
      call MOM_error(FATAL,trim(mod)//', initialize_regridding: '// &
                 'Mismatch in number of model levels and "'//trim(string)//'".')
    endif
    if (main_parameters) call log_param(param_file, mod, "!"//coord_res_param, dz, &
               trim(message), units=coordinateUnits(coord_mode))
  elseif (index(trim(string),'FNC1:')==1) then
    ke = GV%ke; allocate(dz(ke))
    call dz_function1( trim(string(6:)), dz )
    if (main_parameters) call log_param(param_file, mod, "!"//coord_res_param, dz, &
               trim(message), units=coordinateUnits(coord_mode))
  elseif (index(trim(string),'RFNC1:')==1) then
    ! Function used for set target interface densities
    ke = rho_function1( trim(string(7:)), rho_target )
  elseif (index(trim(string),'HYBRID:')==1) then
    ke = GV%ke; allocate(dz(ke))
    ! The following assumes the FILE: syntax of above but without "FILE:" in the string
    allocate(rho_target(ke+1))
    fileName = trim( extractWord(trim(string(8:)), 1) )
    if (fileName(1:1)/='.' .and. filename(1:1)/='/') fileName = trim(inputdir) // trim( fileName )
    if (.not. file_exists(fileName)) call MOM_error(FATAL,trim(mod)//", initialize_regridding: HYBRID "// &
      "Specified file not found: Looking for '"//trim(fileName)//"' ("//trim(string)//")")
    varName = trim( extractWord(trim(string(8:)), 2) )
    if (.not. field_exists(fileName,varName)) call MOM_error(FATAL,trim(mod)//", initialize_regridding: HYBRID "// &
      "Specified field not found: Looking for '"//trim(varName)//"' ("//trim(string)//")")
    call MOM_read_data(trim(fileName), trim(varName), rho_target)
    varName = trim( extractWord(trim(string(8:)), 3) )
    if (varName(1:5) == 'FNC1:') then ! Use FNC1 to calculate dz
      call dz_function1( trim(string((index(trim(string),'FNC1:')+5):)), dz )
    else ! Read dz from file
      if (.not. field_exists(fileName,varName)) call MOM_error(FATAL,trim(mod)//", initialize_regridding: HYBRID "// &
        "Specified field not found: Looking for '"//trim(varName)//"' ("//trim(string)//")")
      call MOM_read_data(trim(fileName), trim(varName), dz)
    endif
    if (main_parameters) then
      call log_param(param_file, mod, "!"//coord_res_param, dz, &
               trim(message), units=coordinateUnits(coord_mode))
      call log_param(param_file, mod, "!TARGET_DENSITIES", rho_target, &
               'HYBRID target densities for itnerfaces', units=coordinateUnits(coord_mode))
    endif
  elseif (index(trim(string),'WOA09')==1) then
    if (len_trim(string)==5) then
      tmpReal = 0. ; ke = 0
      do while (tmpReal<max_depth)
        ke = ke + 1
        tmpReal = tmpReal + woa09_dz(ke)
      enddo
    elseif (index(trim(string),'WOA09:')==1) then
      if (len_trim(string)==6) call MOM_error(FATAL,trim(mod)//', initialize_regridding: '// &
                 'Expected string of form "WOA09:N" but got "'//trim(string)//'".')
      ke = extract_integer(string(7:len_trim(string)),'',1)
    endif
    if (ke>40 .or. ke<1) call MOM_error(FATAL,trim(mod)//', initialize_regridding: '// &
                 'For "WOA05:N" N must 0<N<41 but got "'//trim(string)//'".')
    allocate(dz(ke))
    dz(1:ke) = woa09_dz(1:ke)
  else
    call MOM_error(FATAL,trim(mod)//", initialize_regridding: "// &
      "Unrecognized coordinate configuraiton"//trim(string))
  endif

  if (main_parameters) then
    ! This is a work around to apparently needed to work with the from_Z initialization...  ???
    if (coordinateMode(coord_mode) == REGRIDDING_ZSTAR .or. &
        coordinateMode(coord_mode) == REGRIDDING_HYCOM1 .or. &
        coordinateMode(coord_mode) == REGRIDDING_SLIGHT .or. &
        coordinateMode(coord_mode) == REGRIDDING_ADAPTIVE) then
      ! Adjust target grid to be consistent with max_depth
      tmpReal = sum( dz(:) )
      if (tmpReal < max_depth) then
        dz(ke) = dz(ke) + ( max_depth - tmpReal )
      elseif (tmpReal > max_depth) then
        if ( dz(ke) + ( max_depth - tmpReal ) > 0. ) then
          dz(ke) = dz(ke) + ( max_depth - tmpReal )
        else
          call MOM_error(FATAL,trim(mod)//", initialize_regridding: "// &
            "MAXIMUM_DEPTH was too shallow to adjust bottom layer of DZ!"//trim(string))
        endif
      endif
    endif
  endif

  CS%nk=ke

  ! Target resolution (for fixed coordinates)
  allocate( CS%coordinateResolution(CS%nk) ); CS%coordinateResolution(:) = -1.E30
  if (state_dependent(CS%regridding_scheme)) then
    ! Target values
    allocate( CS%target_density(CS%nk+1) ); CS%target_density(:) = -1.E30
  endif

  if (allocated(dz)) call setCoordinateResolution(dz, CS)

  if (allocated(rho_target)) then
    call set_target_densities(CS, rho_target)
    deallocate(rho_target)

  ! \todo This line looks like it would overwrite the target densities set just above?
  elseif (coordinateMode(coord_mode) == REGRIDDING_RHO) then
    call set_target_densities_from_GV(GV, CS)
    call log_param(param_file, mod, "!TARGET_DENSITIES", CS%target_density, &
             'RHO target densities for interfaces', units=coordinateUnits(coord_mode))
  endif

  ! initialise coordinate-specific control structure
  call initCoord(CS, coord_mode)

  if (main_parameters .and. coord_is_state_dependent) then
    call get_param(param_file, mod, "REGRID_COMPRESSIBILITY_FRACTION", tmpReal, &
                 "When interpolating potential density profiles we can add\n"//&
                 "some artificial compressibility solely to make homogenous\n"//&
                 "regions appear stratified.", default=0.)
    call set_regrid_params(CS, compress_fraction=tmpReal)
  endif

  if (main_parameters) then
    call get_param(param_file, mod, "MIN_THICKNESS", tmpReal, &
                 "When regridding, this is the minimum layer\n"//&
                 "thickness allowed.", units="m",&
                 default=regriddingDefaultMinThickness )
    call set_regrid_params(CS, min_thickness=tmpReal*GV%m_to_H)
  else
    call set_regrid_params(CS, min_thickness=0.)
  endif

  if (coordinateMode(coord_mode) == REGRIDDING_SLIGHT) then
    ! Set SLight-specific regridding parameters.
    call get_param(param_file, mod, "SLIGHT_DZ_SURFACE", dz_fixed_sfc, &
                 "The nominal thickness of fixed thickness near-surface\n"//&
                 "layers with the SLight coordinate.", units="m", default=1.0)
    call get_param(param_file, mod, "SLIGHT_NZ_SURFACE_FIXED", nz_fixed_sfc, &
                 "The number of fixed-depth surface layers with the SLight\n"//&
                 "coordinate.", units="nondimensional", default=2)
    call get_param(param_file, mod, "SLIGHT_SURFACE_AVG_DEPTH", Rho_avg_depth, &
                 "The thickness of the surface region over which to average\n"//&
                 "when calculating the density to use to define the interior\n"//&
                 "with the SLight coordinate.", units="m", default=1.0)
    call get_param(param_file, mod, "SLIGHT_NLAY_TO_INTERIOR", nlay_sfc_int, &
                 "The number of layers to offset the surface density when\n"//&
                 "defining where the interior ocean starts with SLight.", &
                 units="nondimensional", default=2.0)
    call get_param(param_file, mod, "SLIGHT_FIX_HALOCLINES", fix_haloclines, &
                 "If true, identify regions above the reference pressure\n"//&
                 "where the reference pressure systematically underestimates\n"//&
                 "the stratification and use this in the definition of the\n"//&
                 "interior with the SLight coordinate.", default=.false.)

    call set_regrid_params(CS, dz_min_surface=dz_fixed_sfc, &
                nz_fixed_surface=nz_fixed_sfc, Rho_ML_avg_depth=Rho_avg_depth, &
                nlay_ML_to_interior=nlay_sfc_int, fix_haloclines=fix_haloclines)
    if (fix_haloclines) then
      ! Set additional parameters related to SLIGHT_FIX_HALOCLINES.
      call get_param(param_file, mod, "HALOCLINE_FILTER_LENGTH", filt_len, &
                 "A length scale over which to smooth the temperature and\n"//&
                 "salinity before identifying erroneously unstable haloclines.", &
                 units="m", default=2.0)
      call get_param(param_file, mod, "HALOCLINE_STRAT_TOL", strat_tol, &
                 "A tolerance for the ratio of the stratification of the\n"//&
                 "apparent coordinate stratification to the actual value\n"//&
                 "that is used to identify erroneously unstable haloclines.\n"//&
                 "This ratio is 1 when they are equal, and sensible values \n"//&
                 "are between 0 and 0.5.", units="nondimensional", default=0.2)
      call set_regrid_params(CS, halocline_filt_len=filt_len, &
                             halocline_strat_tol=strat_tol)
    endif

  endif

  if (coordinateMode(coord_mode) == REGRIDDING_ADAPTIVE) then
    call get_param(param_file, mod, "ADAPT_ALPHA_RHO", adaptAlphaRho, &
         "Density adaptivity coefficient (use negative value for automatic)", &
         units="nondim", default=-1.0)
    call get_param(param_file, mod, "ADAPT_ALPHA_P", adaptAlphaP, &
         "Pressure adaptivity coefficient (use negative value for automatic)", &
         units="nondim", default=-1.0)
    call get_param(param_file, mod, "ADAPT_KAPPA", adaptKappa, &
         "Timescale for adaptivity diffusivity (defaults to a day)", &
         units="s", default=8640.0)
    call get_param(param_file, mod, "ADAPT_TAU", adaptTau, &
         "Coordinate relaxation timescale", units="s-1", default=0.0)
    call get_param(param_file, mod, "ADAPT_MEAN_H", tmpLogical, &
         "Use mean rather than 'upstream' h in calculations", default=.false.)

    call set_regrid_params(CS, adaptAlphaRho=adaptAlphaRho, adaptAlphaP=adaptAlphaP, &
         adaptKappa=adaptKappa, adaptTau=adaptTau, adaptMean=tmpLogical)
  endif

  if (main_parameters .and. coord_is_state_dependent) then
    call get_param(param_file, mod, "MAXIMUM_INT_DEPTH_CONFIG", string, &
                 "Determines how to specify the maximum interface depths.\n"//&
                 "Valid options are:\n"//&
                 " NONE        - there are no maximum interface depths\n"//&
                 " PARAM       - use the vector-parameter MAXIMUM_INTERFACE_DEPTHS\n"//&
                 " FILE:string - read from a file. The string specifies\n"//&
                 "               the filename and variable name, separated\n"//&
                 "               by a comma or space, e.g. FILE:lev.nc,Z\n"//&
                 " FNC1:string - FNC1:dz_min,H_total,power,precision",&
                 default='NONE')
    message = "The list of maximum depths for each interface."
    allocate(z_max(ke+1))
    allocate(dz_max(ke))
    if ( trim(string) == "NONE") then
      ! Do nothing.
    elseif ( trim(string) ==  "PARAM") then
      call get_param(param_file, mod, "MAXIMUM_INTERFACE_DEPTHS", z_max, &
                   trim(message), units="m", fail_if_missing=.true.)
      call set_regrid_max_depths(CS, z_max, GV%m_to_H)
    elseif (index(trim(string),'FILE:')==1) then
      if (string(6:6)=='.' .or. string(6:6)=='/') then
        ! If we specified "FILE:./xyz" or "FILE:/xyz" then we have a relative or absolute path
        fileName = trim( extractWord(trim(string(6:80)), 1) )
      else
        ! Otherwise assume we should look for the file in INPUTDIR
        fileName = trim(inputdir) // trim( extractWord(trim(string(6:80)), 1) )
      endif
      if (.not. file_exists(fileName)) call MOM_error(FATAL,trim(mod)//", initialize_regridding: "// &
        "Specified file not found: Looking for '"//trim(fileName)//"' ("//trim(string)//")")

      do_sum = .false.
      varName = trim( extractWord(trim(string(6:)), 2) )
      if (.not. field_exists(fileName,varName)) call MOM_error(FATAL,trim(mod)//", initialize_regridding: "// &
        "Specified field not found: Looking for '"//trim(varName)//"' ("//trim(string)//")")
      if (len_trim(varName)==0) then
        if (field_exists(fileName,'z_max')) then; varName = 'z_max'
        elseif (field_exists(fileName,'dz')) then; varName = 'dz' ; do_sum = .true.
        elseif (field_exists(fileName,'dz_max')) then; varName = 'dz_max' ; do_sum = .true.
        else ; call MOM_error(FATAL,trim(mod)//", initialize_regridding: "// &
          "MAXIMUM_INT_DEPTHS variable not specified and none could be guessed.")
        endif
      endif
      if (do_sum) then
        call MOM_read_data(trim(fileName), trim(varName), dz_max)
        z_max(1) = 0.0 ; do K=1,ke ; z_max(K+1) = z_max(K) + dz_max(k) ; enddo
      else
        call MOM_read_data(trim(fileName), trim(varName), z_max)
      endif
      call log_param(param_file, mod, "!MAXIMUM_INT_DEPTHS", z_max, &
                 trim(message), units=coordinateUnits(coord_mode))
      call set_regrid_max_depths(CS, z_max, GV%m_to_H)
    elseif (index(trim(string),'FNC1:')==1) then
      call dz_function1( trim(string(6:)), dz_max )
      if ((coordinateMode(coord_mode) == REGRIDDING_SLIGHT) .and. &
          (dz_fixed_sfc > 0.0)) then
        do k=1,nz_fixed_sfc ; dz_max(k) = dz_fixed_sfc ; enddo
      endif
      z_max(1) = 0.0 ; do K=1,ke ; z_max(K+1) = z_max(K) + dz_max(K) ; enddo
      call log_param(param_file, mod, "!MAXIMUM_INT_DEPTHS", z_max, &
                 trim(message), units=coordinateUnits(coord_mode))
      call set_regrid_max_depths(CS, z_max, GV%m_to_H)
    else
      call MOM_error(FATAL,trim(mod)//", initialize_regridding: "// &
        "Unrecognized MAXIMUM_INT_DEPTH_CONFIG "//trim(string))
    endif
    deallocate(z_max)
    deallocate(dz_max)

    ! Optionally specify maximum thicknesses for each layer, enforced by moving
    ! the interface below a layer downward.
    call get_param(param_file, mod, "MAX_LAYER_THICKNESS_CONFIG", string, &
                   "Determines how to specify the maximum layer thicknesses.\n"//&
                   "Valid options are:\n"//&
                   " NONE        - there are no maximum layer thicknesses\n"//&
                   " PARAM       - use the vector-parameter MAX_LAYER_THICKNESS\n"//&
                   " FILE:string - read from a file. The string specifies\n"//&
                   "               the filename and variable name, separated\n"//&
                   "               by a comma or space, e.g. FILE:lev.nc,Z\n"//&
                   " FNC1:string - FNC1:dz_min,H_total,power,precision",&
                   default='NONE')
    message = "The list of maximum thickness for each layer."
    allocate(h_max(ke))
    if ( trim(string) == "NONE") then
      ! Do nothing.
    elseif ( trim(string) ==  "PARAM") then
      call get_param(param_file, mod, "MAX_LAYER_THICKNESS", h_max, &
                   trim(message), units="m", fail_if_missing=.true.)
      call set_regrid_max_thickness(CS, h_max, GV%m_to_H)
    elseif (index(trim(string),'FILE:')==1) then
      if (string(6:6)=='.' .or. string(6:6)=='/') then
        ! If we specified "FILE:./xyz" or "FILE:/xyz" then we have a relative or absolute path
        fileName = trim( extractWord(trim(string(6:80)), 1) )
      else
        ! Otherwise assume we should look for the file in INPUTDIR
        fileName = trim(inputdir) // trim( extractWord(trim(string(6:80)), 1) )
      endif
      if (.not. file_exists(fileName)) call MOM_error(FATAL,trim(mod)//", initialize_regridding: "// &
        "Specified file not found: Looking for '"//trim(fileName)//"' ("//trim(string)//")")

      varName = trim( extractWord(trim(string(6:)), 2) )
      if (.not. field_exists(fileName,varName)) call MOM_error(FATAL,trim(mod)//", initialize_regridding: "// &
        "Specified field not found: Looking for '"//trim(varName)//"' ("//trim(string)//")")
      if (len_trim(varName)==0) then
        if (field_exists(fileName,'h_max')) then; varName = 'h_max'
        elseif (field_exists(fileName,'dz_max')) then; varName = 'dz_max'
        else ; call MOM_error(FATAL,trim(mod)//", initialize_regridding: "// &
          "MAXIMUM_INT_DEPTHS variable not specified and none could be guessed.")
        endif
      endif
      call MOM_read_data(trim(fileName), trim(varName), h_max)
      call log_param(param_file, mod, "!MAX_LAYER_THICKNESS", h_max, &
                 trim(message), units=coordinateUnits(coord_mode))
      call set_regrid_max_thickness(CS, h_max, GV%m_to_H)
    elseif (index(trim(string),'FNC1:')==1) then
      call dz_function1( trim(string(6:)), h_max )
      call log_param(param_file, mod, "!MAX_LAYER_THICKNESS", h_max, &
                 trim(message), units=coordinateUnits(coord_mode))
      call set_regrid_max_thickness(CS, h_max, GV%m_to_H)
    else
      call MOM_error(FATAL,trim(mod)//", initialize_regridding: "// &
        "Unrecognized MAX_LAYER_THICKNESS_CONFIG "//trim(string))
    endif
    deallocate(h_max)
  endif

  if (allocated(dz)) deallocate(dz)
end subroutine initialize_regridding

!> Do some basic checks on the vertical grid definition file, variable
subroutine check_grid_def(filename, varname, expected_units, msg, ierr)
  character(len=*), intent(in)    :: filename !< File name
  character(len=*), intent(in)    :: varname !< Variable name
  character(len=*), intent(in)    :: expected_units !< Expected units of variable
  character(len=*), intent(inout) :: msg !< Message to use for errors
  logical,          intent(out)   :: ierr !< True if an error occurs
  ! Local variables
  character (len=200) :: units, long_name
  integer :: ncid, status, intid, vid
  integer :: i

  ierr = .false.
  status = NF90_OPEN(trim(filename), NF90_NOWRITE, ncid);
  if (status /= NF90_NOERR) then
    ierr = .true.
    msg = 'File not found: '//trim(filename)
    return
  endif

  status = NF90_INQ_VARID(ncid, trim(varname), vid)
  if (status /= NF90_NOERR) then
    ierr = .true.
    msg = 'Var not found: '//trim(varname)
    return
  endif

  status = NF90_GET_ATT(ncid, vid, "units", units)
  if (status /= NF90_NOERR) then
    ierr = .true.
    msg = 'Attribute not found: units'
    return
  endif
  ! NF90_GET_ATT can return attributes with null characters, which TRIM will not truncate.
  ! This loop replaces any null characters with a space so that the following check between
  ! the read units and the expected units will pass
  do i=1,LEN_TRIM(units)
    if (units(i:i) == CHAR(0)) units(i:i) = " "
  enddo

  if (trim(units) /= trim(expected_units)) then
    if (trim(expected_units) == "meters") then
      if (trim(units) /= "m") then
        ierr = .true.
      endif
    else
      ierr = .true.
    endif
  endif

  if (ierr) then
    msg = 'Units incorrect: '//trim(units)//' /= '//trim(expected_units)
  endif

end subroutine check_grid_def

!> Deallocation of regridding memory
subroutine end_regridding(CS)
  type(regridding_CS), intent(inout) :: CS !< Regridding control structure

  if (associated(CS%zlike_CS))  call end_coord_zlike(CS%zlike_CS)
  if (associated(CS%sigma_CS))  call end_coord_sigma(CS%sigma_CS)
  if (associated(CS%rho_CS))    call end_coord_rho(CS%rho_CS)
  if (associated(CS%hycom_CS))  call end_coord_hycom(CS%hycom_CS)
  if (associated(CS%slight_CS)) call end_coord_slight(CS%slight_CS)
  if (associated(CS%adapt_CS))  call end_coord_adapt(CS%adapt_CS)

  deallocate( CS%coordinateResolution )
  if (allocated(CS%target_density)) deallocate( CS%target_density )
  if (allocated(CS%max_interface_depths) ) deallocate( CS%max_interface_depths )
  if (allocated(CS%max_layer_thickness) ) deallocate( CS%max_layer_thickness )

end subroutine end_regridding

!------------------------------------------------------------------------------
! Dispatching regridding routine: regridding & remapping
!------------------------------------------------------------------------------
subroutine regridding_main( remapCS, CS, G, GV, h, tv, h_new, dzInterface, frac_shelf_h, conv_adjust, dt, diag_CS)
!------------------------------------------------------------------------------
! This routine takes care of (1) building a new grid and (2) remapping between
! the old grid and the new grid. The creation of the new grid can be based
! on z coordinates, target interface densities, sigma coordinates or any
! arbitrary coordinate system.
!   The MOM6 interface positions are always calculated from the bottom up by
! accumulating the layer thicknesses starting at z=-G%bathyT.  z increases
! upwards (decreasing k-index).
!   The new grid is defined by the change in position of those interfaces in z
!       dzInterface = zNew - zOld.
!   Thus, if the regridding inflates the top layer, hNew(1) > hOld(1), then the
! second interface moves downward, zNew(2) < zOld(2), and dzInterface(2) < 0.
!       hNew(k) = hOld(k) - dzInterface(k+1) + dzInterface(k)
! IMPORTANT NOTE:
!   This is the converse of the sign convention used in the remapping code!
!------------------------------------------------------------------------------

  ! Arguments
  type(remapping_CS),                         intent(in)    :: remapCS !< Remapping parameters and options
  type(regridding_CS),                        intent(in)    :: CS     !< Regridding control structure
  type(ocean_grid_type),                      intent(in)    :: G      !< Ocean grid structure
  type(verticalGrid_type),                    intent(in)    :: GV     !< Ocean vertical grid structure
  real, dimension(SZI_(G),SZJ_(G), SZK_(GV)), intent(inout) :: h      !< Current 3D grid obtained after the last time step
  type(thermo_var_ptrs),                      intent(inout) :: tv     !< Thermodynamical variables (T, S, ...)
  real, dimension(SZI_(G),SZJ_(G), SZK_(GV)), intent(inout) :: h_new  !< New 3D grid consistent with target coordinate
  real, dimension(SZI_(G),SZJ_(G), SZK_(GV)+1), intent(inout) :: dzInterface !< The change in position of each interface
  real, dimension(:,:),                   optional, pointer :: frac_shelf_h !< Fractional ice shelf coverage
  logical,                          optional, intent(in   ) :: conv_adjust ! If true, do convective adjustment
  real, optional, intent(in) :: dt !< Current model timestep
  type(adapt_diag_CS), optional, intent(inout) :: diag_CS

  ! Local variables
  real :: trickGnuCompiler
  logical :: use_ice_shelf
  logical :: do_convective_adjustment

  do_convective_adjustment = .true.
  if (present(conv_adjust)) do_convective_adjustment = conv_adjust

  use_ice_shelf = .false.
  if (present(frac_shelf_h)) then
    if (associated(frac_shelf_h)) use_ice_shelf = .true.
  endif

  select case ( CS%regridding_scheme )

    case ( REGRIDDING_ZSTAR )
      if (use_ice_shelf) then
        call build_zstar_grid( CS, G, GV, h, dzInterface, frac_shelf_h )
      else
        call build_zstar_grid( CS, G, GV, h, dzInterface )
      endif
      call calc_h_new_by_dz(G, GV, h, dzInterface, h_new)

    case ( REGRIDDING_SIGMA_SHELF_ZSTAR)
      call build_zstar_grid( CS, G, GV, h, dzInterface )
      call calc_h_new_by_dz(G, GV, h, dzInterface, h_new)

    case ( REGRIDDING_SIGMA )
      call build_sigma_grid( CS, G, GV, h, dzInterface )
      call calc_h_new_by_dz(G, GV, h, dzInterface, h_new)

    case ( REGRIDDING_RHO )
      if (do_convective_adjustment) call convective_adjustment(G, GV, h, tv)
      call build_rho_grid( G, GV, h, tv, dzInterface, remapCS, CS )
      call calc_h_new_by_dz(G, GV, h, dzInterface, h_new)

    case ( REGRIDDING_ARBITRARY )
      call build_grid_arbitrary( G, GV, h, dzInterface, trickGnuCompiler, CS )
      call calc_h_new_by_dz(G, GV, h, dzInterface, h_new)

    case ( REGRIDDING_HYCOM1 )
      call build_grid_HyCOM1( G, GV, h, tv, dzInterface, CS )
      call calc_h_new_by_dz(G, GV, h, dzInterface, h_new)

    case ( REGRIDDING_SLIGHT )
      call build_grid_SLight( G, GV, h, tv, dzInterface, CS )
      call calc_h_new_by_dz(G, GV, h, dzInterface, h_new)

    case ( REGRIDDING_ADAPTIVE )
      call build_grid_adaptive(G, GV, h, tv, dzInterface, remapCS, CS, dt=dt, diag_CS=diag_CS)

      call calc_h_new_by_dz(G, GV, h, dzInterface, h_new)

    case default
      call MOM_error(FATAL,'MOM_regridding, regridding_main: '//&
                     'Unknown regridding scheme selected!')

  end select ! type of grid

#ifdef __DO_SAFETY_CHECKS__
  call check_remapping_grid(G, GV, h, dzInterface,'in regridding_main')
#endif

end subroutine regridding_main

!> Calculates h_new from h + delta_k dzInterface
subroutine calc_h_new_by_dz(G, GV, h, dzInterface, h_new)
  type(ocean_grid_type),                      intent(in)    :: G !< Grid structure
  type(verticalGrid_type),                    intent(in)    :: GV !< Ocean vertical grid structure
  real, dimension(SZI_(G),SZJ_(G),SZK_(GV)),   intent(in)    :: h !< Old layer thicknesses (m)
  real, dimension(SZI_(G),SZJ_(G),SZK_(GV)+1), intent(in)    :: dzInterface !< Change in interface positions (m)
  real, dimension(SZI_(G),SZJ_(G),SZK_(GV)),   intent(inout) :: h_new !< New layer thicknesses (m)
  ! Local variables
  integer :: i, j, k

!$OMP parallel do default(none) shared(G,GV,h,dzInterface,h_new)
  do j = G%jsc-1,G%jec+1
    do i = G%isc-1,G%iec+1
      if (G%mask2dT(i,j)>0.) then
        do k=1,GV%ke
          h_new(i,j,k) = max( 0., h(i,j,k) + ( dzInterface(i,j,k) - dzInterface(i,j,k+1) ) )
        enddo
      else
        h_new(i,j,:) = h(i,j,:)
      endif
    enddo
  enddo

end subroutine calc_h_new_by_dz

!> Check that the total thickness of two grids match
subroutine check_remapping_grid( G, GV, h, dzInterface, msg )
  type(ocean_grid_type),                       intent(in) :: G !< Grid structure
  type(verticalGrid_type),                     intent(in) :: GV !< Ocean vertical grid structure
  real, dimension(SZI_(G),SZJ_(G),SZK_(GV)),   intent(in) :: h !< Layer thicknesses (m)
  real, dimension(SZI_(G),SZJ_(G),SZK_(GV)+1), intent(in) :: dzInterface !< Change in interface positions (m)
  character(len=*),                            intent(in) :: msg !< Message to append to errors
  ! Local variables
  integer :: i, j

!$OMP parallel do default(none) shared(G,GV,h,dzInterface,msg)
  do j = G%jsc-1,G%jec+1
    do i = G%isc-1,G%iec+1
      if (G%mask2dT(i,j)>0.) call check_grid_column( GV%ke, G%bathyT(i,j), h(i,j,:), dzInterface(i,j,:), msg, i, j )
    enddo
  enddo

end subroutine check_remapping_grid

!> Check that the total thickness of new and old grids are consistent
subroutine check_grid_column( nk, depth, h, dzInterface, msg, i, j, dzInterfacePrev, is_fatal )
  integer,               intent(in) :: nk !< Number of cells
  real,                  intent(in) :: depth !< Depth of bottom (m)
  real, dimension(nk),   intent(in) :: h !< Cell thicknesses (m)
  real, dimension(nk+1), intent(in) :: dzInterface !< Change in interface positions (m)
  character(len=*),      intent(in) :: msg !< Message to append to errors
  integer, intent(in) :: i, j !< index of column in question
  real, dimension(nk+1), intent(in), optional :: dzInterfacePrev
  logical, intent(in), optional :: is_fatal
  ! Local variables
  integer :: k, k2, level
  real    :: eps, total_h_old, total_h_new, h_new, z_old, z_new

  ! we might have intermediate checks where negative thicknesses
  ! are permitted (before a call to adjust_interface_motion)
  ! so we don't want those to be fatal
  level = FATAL
  if (present(is_fatal) .and. .not. is_fatal) level = WARNING

  eps =1. ; eps = epsilon(eps)

  ! Total thickness of grid h
  total_h_old = 0.
  do k = 1,nk
    total_h_old = total_h_old + h(k)
  enddo

  ! Integrate upwards for the interfaces consistent with the rest of MOM6
  z_old = - depth
  if (depth == 0.) z_old = - total_h_old
  total_h_new = 0.
  do k = nk,1,-1
    z_old = z_old + h(k) ! Old interface position above layer k
    z_new = z_old + dzInterface(k) ! New interface position based on dzInterface
    h_new = h(k) + ( dzInterface(k) - dzInterface(k+1) ) ! New thickness
    if (h_new<0.) then
      write(0,*) 'i,j,k,h,hnew,depth=',i,j,k,h(k),h_new,depth
      write(0,*) 'dzI(k+1),dzI(k)=',dzInterface(k+1),dzInterface(k)

      do k2 = 1,nk
        write(0,*) 'k,dzI,h,hnew=',k2,dzInterface(k2),h(k2),h(k2)+(dzInterface(k2)-dzInterface(k2+1))
        if (present(dzInterfacePrev)) then
          write(0,*) 'dzIP,hnewP=',dzInterfacePrev(k2),h(k2)+(dzInterfacePrev(k2)-dzInterfacePrev(k2+1))
        endif
      enddo

      call MOM_error( level, 'MOM_regridding, check_grid_column: '//&
        'Negative layer thickness implied by re-gridding, '//trim(msg))
    endif
    total_h_new = total_h_new + h_new

  enddo

  ! Conservation by implied h_new
  if (abs(total_h_new-total_h_old)>real(nk-1)*0.5*(total_h_old+total_h_new)*eps) then
    write(0,*) 'nk=',nk
    do k = 1,nk
      write(0,*) 'k,h,hnew=',k,h(k),h(k)+(dzInterface(k)-dzInterface(k+1))
    enddo
    write(0,*) 'Hold,Hnew,Hnew-Hold=',total_h_old,total_h_new,total_h_new-total_h_old
    write(0,*) 'eps,(n)/2*eps*H=',eps,real(nk-1)*0.5*(total_h_old+total_h_new)*eps
    call MOM_error( FATAL, 'MOM_regridding, check_grid_column: '//&
      'Re-gridding did NOT conserve total thickness to within roundoff '//trim(msg))
  endif

  ! Check that the top and bottom are intentionally moving
  if (dzInterface(1) /= 0.) call MOM_error( FATAL, &
    'MOM_regridding, check_grid_column: Non-zero dzInterface at surface! '//trim(msg))
  if (dzInterface(nk+1) /= 0.) call MOM_error( FATAL, &
    'MOM_regridding, check_grid_column: Non-zero dzInterface at bottom! '//trim(msg))

end subroutine check_grid_column

!> Returns the change in interface position motion after filtering and
!! assuming the top and bottom interfaces do not move.  The filtering is
!! a function of depth, and is applied as the integrated average filtering
!! over the trajectory of the interface.  By design, this code can not give
!! tangled interfaces provided that z_old and z_new are not already tangled.
subroutine filtered_grid_motion( CS, nk, z_old, z_new, dz_g )
  type(regridding_CS),                           intent(in)    :: CS !< Regridding control structure
  integer,               intent(in)    :: nk !< Number of cells
  real, dimension(nk+1), intent(in)    :: z_old !< Old grid position (m)
  real, dimension(nk+1), intent(in)    :: z_new !< New grid position (m)
  real, dimension(nk+1), intent(inout) :: dz_g !< Change in interface positions (m)
  ! Local variables
  real :: sgn  ! The sign convention for downward.
  real :: dz_tgt, zr1
  real :: Aq, Bq, dz0, z0, F0
  real :: zs, zd, dzwt, Idzwt
  real :: wtd, Iwtd
  real :: Int_zs, Int_zd, dInt_zs_zd
! For debugging:
  real, dimension(nk+1) :: z_act
!  real, dimension(nk+1) :: ddz_g_s, ddz_g_d
  logical :: debug = .false.
  integer :: k

  if ((z_old(nk+1) - z_old(1)) * (z_new(nk+1) - z_new(1)) < 0.0) then
    call MOM_error(FATAL, "filtered_grid_motion: z_old and z_new use different sign conventions.")
  elseif ((z_old(nk+1) - z_old(1)) * (z_new(nk+1) - z_new(1)) == 0.0) then
    ! This is a massless column, so do nothing and return.
    do k=1,nk+1 ; dz_g(k) = 0.0 ; enddo ; return
  elseif ((z_old(nk+1) - z_old(1)) + (z_new(nk+1) - z_new(1)) > 0.0) then
    sgn = 1.0
  else
    sgn = -1.0
  endif

  if (debug) then
    do k=2,nk+1
      if (sgn*(z_new(k)-z_new(k-1)) < -5e-16*(abs(z_new(k))+abs(z_new(k-1))) ) &
        call MOM_error(FATAL, "filtered_grid_motion: z_new is tangled.")
      if (sgn*(z_old(k)-z_old(k-1)) < -5e-16*(abs(z_old(k))+abs(z_old(k-1))) ) &
        call MOM_error(FATAL, "filtered_grid_motion: z_old is tangled.")
    enddo
    ! ddz_g_s(:) = 0.0 ; ddz_g_d(:) = 0.0
  endif

  zs = CS%depth_of_time_filter_shallow
  zd = CS%depth_of_time_filter_deep
  wtd = 1.0 - CS%old_grid_weight

  if (wtd == 0.0) then
     Iwtd = 0.0
  else
     Iwtd = 1.0 / wtd
  end if

  dzwt = (zd - zs)
  Idzwt = 0.0 ; if (abs(zd - zs) > 0.0) Idzwt = 1.0 / (zd - zs)
  dInt_zs_zd = 0.5*(1.0 + Iwtd) * (zd - zs)
  Aq = 0.5*(Iwtd - 1.0)

  dz_g(1) = 0.0
  do k = 2,nk
    ! zr1 is positive and increases with depth, and dz_tgt is positive downward.
    dz_tgt = sgn*(z_new(k) - z_old(k))
    zr1 = sgn*(z_old(k) - z_old(1))

    !   First, handle the two simple and common cases that do not pass through
    ! the adjustment rate transition zone.
    if ((zr1 > zd) .and. (zr1 + wtd * dz_tgt > zd)) then
      dz_g(k) = sgn * wtd * dz_tgt
    elseif ((zr1 < zs) .and. (zr1 + dz_tgt < zs)) then
      dz_g(k) = sgn * dz_tgt
    else
      ! Find the new value by inverting the equation
      !   integral(0 to dz_new) Iwt(z) dz = dz_tgt
      ! This is trivial where Iwt is a constant, and agrees with the two limits above.

      ! Take test values at the transition points to figure out which segment
      ! the new value will be found in.
      if (zr1 >= zd) then
        Int_zd = Iwtd*(zd - zr1)
        Int_zs = Int_zd - dInt_zs_zd
      elseif (zr1 <= zs) then
        Int_zs = (zs - zr1)
        Int_zd = dInt_zs_zd + (zs - zr1)
      else
!        Int_zd = (zd - zr1) * (Iwtd + 0.5*(1.0 - Iwtd) * (zd - zr1) / (zd - zs))
        Int_zd = (zd - zr1) * (Iwtd*(0.5*(zd+zr1) - zs) + 0.5*(zd - zr1)) * Idzwt
        Int_zs = (zs - zr1) * (0.5*Iwtd * ((zr1 - zs)) + (zd - 0.5*(zr1+zs))) * Idzwt
        ! It has been verified that  Int_zs = Int_zd - dInt_zs_zd to within roundoff.
      endif

      if (dz_tgt >= Int_zd) then ! The new location is in the deep, slow region.
        dz_g(k) = sgn * ((zd-zr1) + wtd*(dz_tgt - Int_zd))
      elseif (dz_tgt <= Int_zs) then ! The new location is in the shallow region.
        dz_g(k) = sgn * ((zs-zr1) + (dz_tgt - Int_zs))
      else  ! We need to solve a quadratic equation for z_new.
        ! For accuracy, do the integral from the starting depth or the nearest
        ! edge of the transition region.  The results with each choice are
        ! mathematically equivalent, but differ in roundoff, and this choice
        ! should minimize the likelihood of inadvertently overlapping interfaces.
        if (zr1 <= zs) then ; dz0 = zs-zr1 ; z0 = zs ; F0 = dz_tgt - Int_zs
        elseif (zr1 >= zd) then ; dz0 = zd-zr1 ; z0 = zd ; F0 = dz_tgt - Int_zd
        else ; dz0 = 0.0 ; z0 = zr1 ; F0 = dz_tgt ; endif

        Bq = (dzwt + 2.0*Aq*(z0-zs))
        ! Solve the quadratic: Aq*(zn-z0)**2 + Bq*(zn-z0) - F0*dzwt = 0
        ! Note that b>=0, and the two terms in the standard form cancel for the right root.
        dz_g(k) = sgn * (dz0 + 2.0*F0*dzwt / (Bq + sqrt(Bq**2 + 4.0*Aq*F0*dzwt) ))

!       if (debug) then
!         dz0 = zs-zr1 ; z0 = zs ; F0 = dz_tgt - Int_zs ; Bq = (dzwt + 2.0*Aq*(z0-zs))
!         ddz_g_s(k) = sgn * (dz0 + 2.0*F0*dzwt / (Bq + sqrt(Bq**2 + 4.0*Aq*F0*dzwt) )) - dz_g(k)
!         dz0 = zd-zr1 ; z0 = zd ; F0 = dz_tgt - Int_zd ; Bq = (dzwt + 2.0*Aq*(z0-zs))
!         ddz_g_d(k) = sgn * (dz0 + 2.0*F0*dzwt / (Bq + sqrt(Bq**2 + 4.0*Aq*F0*dzwt) )) - dz_g(k)
!
!         if (abs(ddz_g_s(k)) > 1e-12*(abs(dz_g(k)) + abs(dz_g(k)+ddz_g_s(k)))) &
!           call MOM_error(WARNING, "filtered_grid_motion: Expect z_output to be tangled (sc).")
!         if (abs(ddz_g_d(k) - ddz_g_s(k)) > 1e-12*(abs(dz_g(k)+ddz_g_d(k)) + abs(dz_g(k)+ddz_g_s(k)))) &
!           call MOM_error(WARNING, "filtered_grid_motion: Expect z_output to be tangled.")
!       endif
      endif

    endif
  enddo
  dz_g(nk+1) = 0.0

  if (debug) then
    do k=1,nk+1 ; z_act(k) = z_old(k) + dz_g(k) ; enddo
    do k=2,nk+1
      if (sgn*((z_act(k))-z_act(k-1)) < -1e-15*(abs(z_act(k))+abs(z_act(k-1))) ) &
        call MOM_error(FATAL, "filtered_grid_motion: z_output is tangled.")
    enddo
  endif

end subroutine filtered_grid_motion

!> Builds a z*-ccordinate grid with partial steps (Adcroft and Campin, 2004).
!! z* is defined as
!!   z* = (z-eta)/(H+eta)*H  s.t. z*=0 when z=eta and z*=-H when z=-H .
subroutine build_zstar_grid( CS, G, GV, h, dzInterface, frac_shelf_h)

  ! Arguments
  type(regridding_CS),                          intent(in)    :: CS !< Regridding control structure
  type(ocean_grid_type),                        intent(in)    :: G  !< Ocean grid structure
  type(verticalGrid_type),                      intent(in)    :: GV !< ocean vertical grid structure
  real, dimension(SZI_(G),SZJ_(G),SZK_(GV)),    intent(in)    :: h  !< Layer thicknesses, in H
  real, dimension(SZI_(G),SZJ_(G), SZK_(GV)+1), intent(inout) :: dzInterface !< The change in interface depth in H.
  real, dimension(:,:),               optional, pointer       :: frac_shelf_h !< Fractional ice shelf coverage.
  ! Local variables
  integer :: i, j, k
  integer :: nz
  real    :: nominalDepth, totalThickness, dh
  real, dimension(SZK_(GV)+1) :: zOld, zNew
  real :: minThickness
  logical :: ice_shelf

  nz = GV%ke
  minThickness = CS%min_thickness
  ice_shelf = .false.
  if (present(frac_shelf_h)) then
    if (associated(frac_shelf_h)) ice_shelf = .true.
  endif

!$OMP parallel do default(none) shared(G,GV,dzInterface,CS,nz,h,frac_shelf_h, &
!$OMP                                  ice_shelf,minThickness) &
!$OMP                          private(nominalDepth,totalThickness, &
!$OMP                                  zNew,dh,zOld)
  do j = G%jsc-1,G%jec+1
    do i = G%isc-1,G%iec+1

      if (G%mask2dT(i,j)==0.) then
        dzInterface(i,j,:) = 0.
        cycle
      endif

      ! Local depth (G%bathyT is positive)
      nominalDepth = G%bathyT(i,j)*GV%m_to_H

      ! Determine water column thickness
      totalThickness = 0.0
      do k = 1,nz
        totalThickness = totalThickness + h(i,j,k)
      end do

      zOld(nz+1) = - nominalDepth
      do k = nz,1,-1
        zOld(k) = zOld(k+1) + h(i,j,k)
      enddo

      if (ice_shelf) then
        if (frac_shelf_h(i,j) > 0.) then ! under ice shelf
          call build_zstar_column(CS%zlike_CS, nz, nominalDepth, totalThickness, zNew, &
                                z_rigid_top = totalThickness-nominalDepth, &
                                eta_orig=zOld(1), zScale=GV%m_to_H)
        else
          call build_zstar_column(CS%zlike_CS, nz, nominalDepth, totalThickness, &
                                zNew, zScale=GV%m_to_H)
        endif
      else
        call build_zstar_column(CS%zlike_CS, nz, nominalDepth, totalThickness, &
                                zNew, zScale=GV%m_to_H)
      endif

      ! Calculate the final change in grid position after blending new and old grids
      call filtered_grid_motion( CS, nz, zOld, zNew, dzInterface(i,j,:) )

#ifdef __DO_SAFETY_CHECKS__
      dh=max(nominalDepth,totalThickness)
      if (abs(zNew(1)-zOld(1))>(nz-1)*0.5*epsilon(dh)*dh) then
        write(0,*) 'min_thickness=',minThickness
        write(0,*) 'nominalDepth=',nominalDepth,'totalThickness=',totalThickness
        write(0,*) 'dzInterface(1) = ',dzInterface(i,j,1),epsilon(dh),nz
        do k=1,nz+1
          write(0,*) k,zOld(k),zNew(k)
        enddo
        do k=1,nz
          write(0,*) k,h(i,j,k),zNew(k)-zNew(k+1),CS%coordinateResolution(k)
        enddo
        call MOM_error( FATAL, &
               'MOM_regridding, build_zstar_grid(): top surface has moved!!!' )
      endif
#endif

      call adjust_interface_motion( nz, CS%min_thickness, h(i,j,:), dzInterface(i,j,:) )

    end do
  end do

end subroutine build_zstar_grid

!------------------------------------------------------------------------------
! Build sigma grid
!------------------------------------------------------------------------------
subroutine build_sigma_grid( CS, G, GV, h, dzInterface )
!------------------------------------------------------------------------------
! This routine builds a grid based on terrain-following coordinates.
! The module parameter coordinateResolution(:) determines the resolution in
! sigma coordinate, dSigma(:). sigma-coordinates are defined by
!   sigma = (eta-z)/(H+eta)  s.t. sigma=0 at z=eta and sigma=1 at z=-H .
!------------------------------------------------------------------------------

  ! Arguments
  type(regridding_CS),                          intent(in)    :: CS !< Regridding control structure
  type(ocean_grid_type),                        intent(in)    :: G  !< Ocean grid structure
  type(verticalGrid_type),                      intent(in)    :: GV !< ocean vertical grid structure
  real, dimension(SZI_(G),SZJ_(G),SZK_(GV)),    intent(in)    :: h  !< Layer thicknesses, in H
  real, dimension(SZI_(G),SZJ_(G), SZK_(GV)+1), intent(inout) :: dzInterface !< The change in interface depth in H.

  ! Local variables
  integer :: i, j, k
  integer :: nz
  real    :: nominalDepth, totalThickness, dh
  real, dimension(SZK_(GV)+1) :: zOld, zNew

  nz = GV%ke

  do i = G%isc-1,G%iec+1
    do j = G%jsc-1,G%jec+1

      if (G%mask2dT(i,j)==0.) then
        dzInterface(i,j,:) = 0.
        cycle
      endif

      ! The rest of the model defines grids integrating up from the bottom
      nominalDepth = G%bathyT(i,j)*GV%m_to_H

      ! Determine water column height
      totalThickness = 0.0
      do k = 1,nz
        totalThickness = totalThickness + h(i,j,k)
      end do

      call build_sigma_column(CS%sigma_CS, nz, nominalDepth, totalThickness, zNew)

      ! Calculate the final change in grid position after blending new and old grids
      zOld(nz+1) =  -nominalDepth
      do k = nz,1,-1
        zOld(k) = zOld(k+1) + h(i, j, k)
      end do

      call filtered_grid_motion( CS, nz, zOld, zNew, dzInterface(i,j,:) )

#ifdef __DO_SAFETY_CHECKS__
      dh=max(nominalDepth,totalThickness)
      if (abs(zNew(1)-zOld(1))>(nz-1)*0.5*epsilon(dh)*dh) then
        write(0,*) 'min_thickness=',CS%min_thickness
        write(0,*) 'nominalDepth=',nominalDepth,'totalThickness=',totalThickness
        write(0,*) 'dzInterface(1) = ',dzInterface(i,j,1),epsilon(dh),nz
        do k=1,nz+1
          write(0,*) k,zOld(k),zNew(k)
        enddo
        do k=1,nz
          write(0,*) k,h(i,j,k),zNew(k)-zNew(k+1),totalThickness*CS%coordinateResolution(k),CS%coordinateResolution(k)
        enddo
        call MOM_error( FATAL, &
               'MOM_regridding, build_sigma_grid: top surface has moved!!!' )
      endif
      dzInterface(i,j,1) = 0.
      dzInterface(i,j,nz+1) = 0.
#endif

    end do
  end do

end subroutine build_sigma_grid

!------------------------------------------------------------------------------
! Build grid based on target interface densities
!------------------------------------------------------------------------------
subroutine build_rho_grid( G, GV, h, tv, dzInterface, remapCS, CS )
!------------------------------------------------------------------------------
! This routine builds a new grid based on a given set of target interface
! densities (these target densities are computed by taking the mean value
! of given layer densities). The algorithn operates as follows within each
! column:
! 1. Given T & S within each layer, the layer densities are computed.
! 2. Based on these layer densities, a global density profile is reconstructed
!    (this profile is monotonically increasing and may be discontinuous)
! 3. The new grid interfaces are determined based on the target interface
!    densities.
! 4. T & S are remapped onto the new grid.
! 5. Return to step 1 until convergence or until the maximum number of
!    iterations is reached, whichever comes first.
!------------------------------------------------------------------------------

  ! Arguments
  type(ocean_grid_type),                        intent(in)    :: G  !< Ocean grid structure
  type(verticalGrid_type),                      intent(in)    :: GV !< Ocean vertical grid structure
  real, dimension(SZI_(G),SZJ_(G),SZK_(GV)),    intent(in)    :: h  !< Layer thicknesses, in H
  type(thermo_var_ptrs),                        intent(in)    :: tv !< Thermodynamics structure
  real, dimension(SZI_(G),SZJ_(G), SZK_(GV)+1), intent(inout) :: dzInterface !< The change in interface depth in H
  type(remapping_CS),                           intent(in)    :: remapCS !< The remapping control structure
  type(regridding_CS),                          intent(in)    :: CS !< Regridding control structure

  ! Local variables
  integer :: nz
  integer :: i, j, k
  real    :: nominalDepth, totalThickness
  real, dimension(SZK_(GV)+1) :: zOld, zNew
  real :: h_neglect, h_neglect_edge
#ifdef __DO_SAFETY_CHECKS__
  real    :: dh
#endif

  !### Try replacing both of these with GV%H_subroundoff
  if (GV%Boussinesq) then
    h_neglect = GV%m_to_H*1.0e-30 ; h_neglect_edge = GV%m_to_H*1.0e-10
  else
    h_neglect = GV%kg_m2_to_H*1.0e-30 ; h_neglect_edge = GV%kg_m2_to_H*1.0e-10
  endif

  nz = GV%ke

  if (.not.CS%target_density_set) call MOM_error(FATAL, "build_rho_grid: "//&
        "Target densities must be set before build_rho_grid is called.")

  ! Build grid based on target interface densities
  do j = G%jsc-1,G%jec+1
    do i = G%isc-1,G%iec+1

      if (G%mask2dT(i,j)==0.) then
        dzInterface(i,j,:) = 0.
        cycle
      endif


      ! Local depth (G%bathyT is positive)
      nominalDepth = G%bathyT(i,j)*GV%m_to_H

      call build_rho_column(CS%rho_CS, nz, nominalDepth, h(i, j, :), &
                            tv%T(i, j, :), tv%S(i, j, :), tv%eqn_of_state, zNew, &
                            h_neglect=h_neglect, h_neglect_edge=h_neglect_edge)

      if (CS%integrate_downward_for_e) then
        zOld(1) = 0.
        do k = 1,nz
          zOld(k+1) = zOld(k) - h(i,j,k)
        enddo
      else
        ! The rest of the model defines grids integrating up from the bottom
        zOld(nz+1) = - nominalDepth
        do k = nz,1,-1
          zOld(k) = zOld(k+1) + h(i,j,k)
        enddo
      endif

      ! Calculate the final change in grid position after blending new and old grids
      call filtered_grid_motion( CS, nz, zOld, zNew, dzInterface(i,j,:) )

#ifdef __DO_SAFETY_CHECKS__
      do k = 2,nz
        if (zNew(k) > zOld(1)) then
          write(0,*) 'zOld=',zOld
          write(0,*) 'zNew=',zNew
          call MOM_error( FATAL, 'MOM_regridding, build_rho_grid: '//&
               'interior interface above surface!' )
        endif
        if (zNew(k) > zNew(k-1)) then
          write(0,*) 'zOld=',zOld
          write(0,*) 'zNew=',zNew
          call MOM_error( FATAL, 'MOM_regridding, build_rho_grid: '//&
               'interior interfaces cross!' )
        endif
      enddo

      totalThickness = 0.0
      do k = 1,nz
        totalThickness = totalThickness + h(i,j,k)
      enddo

      dh=max(nominalDepth,totalThickness)
      if (abs(zNew(1)-zOld(1))>(nz-1)*0.5*epsilon(dh)*dh) then
        write(0,*) 'min_thickness=',CS%min_thickness
        write(0,*) 'nominalDepth=',nominalDepth,'totalThickness=',totalThickness
        write(0,*) 'zNew(1)-zOld(1) = ',zNew(1)-zOld(1),epsilon(dh),nz
        do k=1,nz+1
          write(0,*) k,zOld(k),zNew(k)
        enddo
        do k=1,nz
          write(0,*) k,h(i,j,k),zNew(k)-zNew(k+1)
        enddo
        call MOM_error( FATAL, &
               'MOM_regridding, build_rho_grid: top surface has moved!!!' )
      endif
#endif

    end do  ! end loop on i
  end do  ! end loop on j

end subroutine build_rho_grid




!> Builds a simple HyCOM-like grid with the deepest location of potential
!! density interpolated from the column profile and a clipping of depth for
!! each interface to a fixed z* or p* grid.  This should probably be (optionally?)
!! changed to find the nearest location of the target density.
!! \remark { Based on Bleck, 2002: An oceanice general circulation model framed in
!! hybrid isopycnic-Cartesian coordinates, Ocean Modelling 37, 55-88.
!! http://dx.doi.org/10.1016/S1463-5003(01)00012-9 }
subroutine build_grid_HyCOM1( G, GV, h, tv, dzInterface, CS )
  type(ocean_grid_type),                       intent(in)    :: G  !< Grid structure
  type(verticalGrid_type),                     intent(in)    :: GV !< Ocean vertical grid structure
  real, dimension(SZI_(G),SZJ_(G),SZK_(GV)),   intent(in)    :: h  !< Existing model thickness, in H units
  type(thermo_var_ptrs),                       intent(in)    :: tv !< Thermodynamics structure
  real, dimension(SZI_(G),SZJ_(G),SZK_(GV)+1), intent(inout) :: dzInterface !< Changes in interface position
  type(regridding_CS),                         intent(in)    :: CS !< Regridding control structure

  ! Local variables
  real, dimension(SZK_(GV)+1) :: z_col, z_col_new ! Interface positions relative to the surface in H units (m or kg m-2)
  real, dimension(SZK_(GV)+1) :: dz_col  ! The realized change in z_col in H units (m or kg m-2)
  real, dimension(SZK_(GV))   :: p_col   ! Layer pressure in Pa
  integer   :: i, j, k, nz
  real :: depth
  real :: h_neglect, h_neglect_edge

  !### Try replacing both of these with GV%H_subroundoff
  if (GV%Boussinesq) then
    h_neglect = GV%m_to_H*1.0e-30 ; h_neglect_edge = GV%m_to_H*1.0e-10
  else
    h_neglect = GV%kg_m2_to_H*1.0e-30 ; h_neglect_edge = GV%kg_m2_to_H*1.0e-10
  endif

  nz = GV%ke

  if (.not.CS%target_density_set) call MOM_error(FATAL, "build_grid_HyCOM1 : "//&
        "Target densities must be set before build_grid_HyCOM1 is called.")

  ! Build grid based on target interface densities
  do j = G%jsc-1,G%jec+1 ; do i = G%isc-1,G%iec+1
    if (G%mask2dT(i,j)>0.) then

      depth = G%bathyT(i,j) * GV%m_to_H

      z_col(1) = 0. ! Work downward rather than bottom up
      do K = 1, nz
        z_col(K+1) = z_col(K) + h(i,j,k) ! Work in units of h (m or Pa)
        p_col(k) = CS%ref_pressure + CS%compressibility_fraction * &
             ( 0.5 * ( z_col(K) + z_col(K+1) ) * GV%H_to_Pa - CS%ref_pressure )
      enddo

      call build_hycom1_column(CS%hycom_CS, tv%eqn_of_state, nz, depth, &
                               h(i, j, :), tv%T(i, j, :), tv%S(i, j, :), p_col, &
                               z_col, z_col_new, zScale=GV%m_to_H, &
                               h_neglect=h_neglect, h_neglect_edge=h_neglect_edge)

      ! Calculate the final change in grid position after blending new and old grids
      call filtered_grid_motion( CS, nz, z_col, z_col_new, dz_col )
      do K=1,nz+1 ; dzInterface(i,j,K) = -dz_col(K) ; enddo

      ! This adjusts things robust to round-off errors
      call adjust_interface_motion( nz, CS%min_thickness, h(i,j,:), dzInterface(i,j,:) )

    else ! on land
      dzInterface(i,j,:) = 0.
    endif ! mask2dT
  enddo; enddo ! i,j

end subroutine build_grid_HyCOM1

subroutine build_grid_adaptive(G, GV, h, tv, dzInterface, remapCS, CS, dt, diag_CS)
  type(ocean_grid_type),                       intent(in)    :: G    !< The ocean's grid structure
  type(verticalGrid_type),                     intent(in)    :: GV   !< The ocean's vertical grid structure
  real, dimension(SZI_(G),SZJ_(G),SZK_(GV)),   intent(in)    :: h    !< Layer thicknesses, in H (usually m or kg m-2)
  type(thermo_var_ptrs),                       intent(in)    :: tv   !< A structure pointing to various thermodynamic variables
  real, dimension(SZI_(G),SZJ_(G),SZK_(GV)+1), intent(inout) :: dzInterface
  type(remapping_CS),                          intent(in)    :: remapCS
  type(regridding_CS),                         intent(in)    :: CS
  real, optional, intent(in) :: dt
  type(adapt_diag_CS), optional, intent(inout) :: diag_CS

  ! local variables
  integer :: i, j, k, nz ! indices and dimension lengths

  ! temperature, salinity and pressure on interfaces
  real, dimension(SZI_(G),SZJ_(G)) :: t_int, t_int_kp1, s_int, s_int_kp1, dk_sig_int
  real, dimension(SZI_(G),SZJ_(G),SZK_(GV)+1) :: z_int
  real, dimension(SZI_(G),SZJ_(G)) :: alpha_int, alpha_int_kp1
  real, dimension(SZI_(G),SZJ_(G)) :: beta_int, beta_int_kp1
  real, dimension(SZIB_(G),SZJ_(G)) :: dz_i, dz_p_i
  real, dimension(SZI_(G),SZJB_(G)) :: dz_j, dz_p_j
  real, dimension(SZI_(G),SZJ_(G),SZK_(GV)) :: dk_sig, dk_sig_prenorm
  real, dimension(SZI_(G),SZJ_(G),SZK_(GV)+1) :: dz_a, dz_p

  real, dimension(SZK_(GV)+1) :: z_old, z_new, z_tgt, dzInterfacePrev

  real, dimension(SZIB_(G),SZJ_(G),SZK_(GV)+1) :: hdi_sig, h_on_i
  real, dimension(SZI_(G),SZJB_(G),SZK_(GV)+1) :: hdj_sig, h_on_j
  real :: di_pre, dj_pre
  real :: extent_left, extent_right
  real :: tmpi, tmpj, tmpk, weight, weight2, h_interp, i_denom, j_denom
  real :: eps, di_sig, dj_sig, hdj_sig_u, hdi_sig_v

  logical :: do_diag

#ifdef __DO_SAFETY_CHECKS__
  real :: total_thickness, dh
  character(len=200) :: tmp_char
#endif

  ! temporary warning, we could probably assume some limit without a specified timestep
  if (.not. present(dt)) &
       call MOM_error(FATAL, 'build_grid_adaptive called without a timestep!')

  eps = 1.
  eps = epsilon(eps)

  do_diag = present(diag_CS)

  nz = GV%ke

  ! calculate interface positions
  ! position bottom on topography
  z_int(:,:,nz+1) = -G%bathyT(:,:)
  do K = nz, 1, -1
    z_int(:,:,K) = z_int(:,:,K+1) + h(:,:,k)
  enddo

  dz_a(:,:,1) = 0.
  dz_a(:,:,nz+1) = 0.

  ! zero out diagnostic arrays
  if (do_diag) then
    if (associated(diag_CS%dens_weight_u)) diag_CS%dens_weight_u(:,:,:) = 0.
    if (associated(diag_CS%pres_weight_u)) diag_CS%pres_weight_u(:,:,:) = 0.
    if (associated(diag_CS%dens_weight_v)) diag_CS%dens_weight_v(:,:,:) = 0.
    if (associated(diag_CS%pres_weight_v)) diag_CS%pres_weight_v(:,:,:) = 0.
    if (associated(diag_CS%slope_u)) diag_CS%slope_u(:,:,:) = 0.
    if (associated(diag_CS%slope_v)) diag_CS%slope_v(:,:,:) = 0.
  endif

  ! populate data ahead of first interface
  ! we need an extra ring of tracer points containing information
  ! so that we can interpolate onto cell faces for flux calculations
  do j = G%jsc-2,G%jec+2
    do i = G%isc-2,G%iec+2
      t_int_kp1(i,j) = ( &
           tv%t(i,j,1) * (h(i,j,2) + GV%H_subroundoff) + &
           tv%t(i,j,2) * (h(i,j,1) + GV%H_subroundoff)) / &
           (h(i,j,1) + h(i,j,2) + 2*GV%H_subroundoff)
      s_int_kp1(i,j) = ( &
           tv%s(i,j,1) * (h(i,j,2) + GV%H_subroundoff) + &
           tv%s(i,j,2) * (h(i,j,1) + GV%H_subroundoff)) / &
           (h(i,j,1) + h(i,j,2) + 2*GV%H_subroundoff)

      ! t_int_kp1(i,j) = 0.5 * (tv%t(i,j,1) + tv%t(i,j,2))
      ! s_int_kp1(i,j) = 0.5 * (tv%s(i,j,1) + tv%s(i,j,2))
    enddo

    ! calculate density derivatives on interfaces
    call calculate_density_derivs(tv%t(:,j,1), tv%s(:,j,1), -z_int(:,j,1) * GV%H_to_Pa, &
         alpha_int(:,j), beta_int(:,j), G%isc-2, G%iec+2 - (G%isc-2) + 1, tv%eqn_of_state)
    call calculate_density_derivs(t_int_kp1(:,j), s_int_kp1(:,j), -z_int(:,j,2) * GV%H_to_Pa, &
         alpha_int_kp1(:,j), beta_int_kp1(:,j), G%isc-2, G%iec+2 - (G%isc-2) + 1, tv%eqn_of_state)

    do i = G%isc-2,G%iec+2
      dk_sig(i,j,1) = 0.5 * (alpha_int(i,j) + alpha_int_kp1(i,j)) * (t_int_kp1(i,j) - tv%t(i,j,1)) &
           + 0.5 * (beta_int(i,j) + beta_int_kp1(i,j)) * (s_int_kp1(i,j) - tv%s(i,j,1))
      dk_sig_prenorm(i,j,1) = dk_sig(i,j,1)
      dk_sig(i,j,1) = max(dk_sig(i,j,1), 0.)
    enddo
  enddo

  do K = 2,nz
    do j = G%jsc-2,G%jec+2
      do i = G%isc-2,G%iec+2
        ! copy from interface ahead
        t_int(i,j) = t_int_kp1(i,j)
        s_int(i,j) = s_int_kp1(i,j)
        alpha_int(i,j) = alpha_int_kp1(i,j)
        beta_int(i,j) = beta_int_kp1(i,j)

        if (k == nz) then
          ! use constant value for bottom interface
          t_int_kp1(i,j) = tv%t(i,j,nz)
          s_int_kp1(i,j) = tv%s(i,j,nz)
        else
          ! calculate ahead one interface (interior)
          t_int_kp1(i,j) = ( &
               tv%t(i,j,k) * (h(i,j,k+1) + GV%H_subroundoff) + &
               tv%t(i,j,k+1) * (h(i,j,k) + GV%H_subroundoff)) / &
               (h(i,j,k) + h(i,j,k+1) + 2*GV%H_subroundoff)
          s_int_kp1(i,j) = ( &
               tv%s(i,j,k) * (h(i,j,k+1) + GV%H_subroundoff) + &
               tv%s(i,j,k+1) * (h(i,j,k) + GV%H_subroundoff)) / &
               (h(i,j,k) + h(i,j,k+1) + 2*GV%H_subroundoff)

          ! t_int_kp1(i,j) = 0.5 * (tv%t(i,j,k) + tv%t(i,j,k+1))
          ! s_int_kp1(i,j) = 0.5 * (tv%s(i,j,k) + tv%s(i,j,k+1))
        endif
      enddo

      call calculate_density_derivs(t_int_kp1(:,j), s_int_kp1(:,j), -z_int(:,j,K+1) * GV%H_to_Pa, &
           alpha_int_kp1(:,j), beta_int_kp1(:,j), G%isc-2, G%iec+2 - (G%isc-2) + 1, tv%eqn_of_state)

      do i = G%isc-2,G%iec+2
        dk_sig(i,j,k) = 0.5 * (alpha_int(i,j) + alpha_int_kp1(i,j)) * (t_int_kp1(i,j) - t_int(i,j)) &
             + 0.5 * (beta_int(i,j) + beta_int_kp1(i,j)) * (s_int_kp1(i,j) - s_int(i,j))
        dk_sig_prenorm(i,j,k) = dk_sig(i,j,k)
        dk_sig(i,j,k) = max(dk_sig(i,j,k), 0.)

        dk_sig_int(i,j) = alpha_int(i,j) * (tv%t(i,j,k) - tv%t(i,j,k-1)) + &
             beta_int(i,j) * (tv%s(i,j,k) - tv%s(i,j,k-1))
      enddo
    enddo

    ! calculate horizontal derivatives on i-points
    do j = G%jsc-2,G%jec+2
      do I = G%isc-2,G%iec+1
        di_sig = 0.5 * (alpha_int(i,j) + alpha_int(i+1,j)) * (t_int(i+1,j) - t_int(i,j)) &
             + 0.5 * (beta_int(i,j) + beta_int(i+1,j)) * (s_int(i+1,j) - s_int(i,j))
        ! calculate hdi_sig by upstreamed h
        if (di_sig < 0.) then
          h_interp = 0.5 * (h(i,j,k-1) + h(i+1,j,k))
        else
          h_interp = 0.5 * (h(i,j,k) + h(i+1,j,k-1))
        end if

        if (CS%adapt_CS%mean_h) &
             h_interp = 0.25 * ((h(i,j,k-1) + h(i+1,j,k)) + (h(i,j,k) + h(i+1,j,k-1)))

        h_on_i(I,j,K) = h_interp
        hdi_sig(I,j,K) = h_interp * di_sig * G%IdxCu(I,j)
      enddo
    enddo
    ! calculate horizontal derivatives on j-points
    do J = G%jsc-2,G%jec+1
      do i = G%isc-2,G%iec+2
        dj_sig = 0.5 * (alpha_int(i,j) + alpha_int(i,j+1)) * (t_int(i,j+1) - t_int(i,j)) &
             + 0.5 * (beta_int(i,j) + beta_int(i,j+1)) * (s_int(i,j+1) - s_int(i,j))

        if (dj_sig < 0.) then
          h_interp = 0.5 * (h(i,j,k-1) + h(i,j+1,k))
        else
          h_interp = 0.5 * (h(i,j,k) + h(i,j+1,k-1))
        end if

        if (CS%adapt_CS%mean_h) &
             h_interp = 0.25 * ((h(i,j,k-1) + h(i+1,j,k)) + (h(i,j,k) + h(i+1,j,k-1)))

        h_on_j(i,J,K) = h_interp
        hdj_sig(i,J,K) = h_interp * dj_sig * G%IdyCv(i,J)
      enddo
    enddo

    ! u-points -- these are calculated regardless of the symmetric memory setting
    ! -- we need to calculate the flux at the north and south of our domain
    ! G%isc-1:G%iec+1 -- so we need an extra point on the south
    do j = G%jsc-1,G%jec+1
      do I = G%isc-2,G%iec+1
        dz_p_i(I,j) = 0.0

        hdj_sig_u = 0.25 * ((hdj_sig(i,J,K)**2 + hdj_sig(i+1,J-1,K)**2) + &
             (hdj_sig(i+1,J,K)**2 + hdj_sig(i,J-1,K)**2))

        i_denom = sqrt(hdi_sig(I,j,K)**2 + hdj_sig_u + &
             0.5 * (dk_sig_int(i,j)**2 + dk_sig_int(i+1,j)**2))
        if (i_denom == 0.) then
          dz_i(I,j) = 0.
        else
          dz_i(I,j) = hdi_sig(I,j,K) / i_denom
        end if

        if (do_diag .and. associated(diag_CS%slope_u)) diag_CS%slope_u(I,j,K) = dz_i(I,j)
        dz_i(I,j) = -dz_i(I,j) * G%dxCu(I,j)**2 * dt / CS%adapt_CS%adaptKappa

        if (do_diag .and. associated(diag_CS%denom_u)) diag_CS%denom_u(I,j,K) = i_denom / (h_on_i(I,j,K) + GV%H_subroundoff)

        ! limit slope based on adjacent layers
        ! dz_i has opposite sign to hdi_sig
        if (dz_i(I,j) < 0.) then
          ! hdi_sig positive -- left down, right up
          dz_i(I,j) = max(dz_i(I,j), -0.125 * min( &
               h(i,j,k) * G%areaT(i,j), &
               h(i+1,j,k-1) * G%areaT(i+1,j)) * G%IdyCu(I,j))
        else
          ! hdi_sig negative -- left up, right down
          dz_i(I,j) = min(dz_i(I,j), 0.125 * min( &
               h(i,j,k-1) * G%areaT(i,j), &
               h(i+1,j,k) * G%areaT(i+1,j)) * G%IdyCu(I,j))
        end if

        ! we also calculate the difference in pressure (interface position)
        dz_p_i(I,j) = 0.5 * (z_int(i+1,j,K) - z_int(i,j,K))
        ! dz_p_i positive => left is further down than right
        ! => move left up, right down

        if (dz_p_i(I,j) > 0.) then
          ! dz_p_i positive -- left up, right down
          dz_p_i(I,j) = min(dz_p_i(I,j), 0.25 * min(h(i,j,k-1), h(i+1,j,k)))
        else
          ! dz_p_i negative -- right up, left down
          dz_p_i(I,j) = max(dz_p_i(I,j), -0.25 * min(h(i,j,k), h(i+1,j,k-1)))
        end if

        tmpi = 0. ; tmpj = 0. ; tmpk = 0.
        if (tmpi + tmpj + tmpk == 0.) then
          i_denom = 0.0
        else
          i_denom = 1.0 / (tmpi + tmpj + tmpk)
        endif

        weight = tmpk * i_denom
        weight2 = (tmpi + tmpj) * i_denom
        if (do_diag .and. associated(diag_CS%dens_weight_u)) diag_CS%dens_weight_u(I,j,K) = weight
        if (do_diag .and. associated(diag_CS%pres_weight_u)) diag_CS%pres_weight_u(I,j,K) = weight2

#ifdef __DO_SAFETY_CHECKS__
        if (weight > 1. .or. weight2 > 1.) call MOM_error(FATAL, 'build_grid_adaptive: Weight greater than 1')
        if (weight < 0. .or. weight2 < 0.) call MOM_error(FATAL, 'build_grid_adaptive: Negative weight')

        if (weight + weight2 /= 0.0 .and. abs(1. - (weight + weight2)) > 1e-6) then
          write (tmp_char,*) 'sum of weights: ', weight + weight2
          call MOM_error(WARNING, tmp_char)
          call MOM_error(FATAL, 'build_grid_adaptive: Weights do not sum to 1')
        endif
#endif

        if (CS%adapt_CS%adaptAlphaRho >= 0.) then
          weight = CS%adapt_CS%adaptAlphaRho

          if (CS%adapt_CS%adaptAlphaP < 0.) then
            weight2 = 1.0 - CS%adapt_CS%adaptAlphaRho
          else
            weight2 = CS%adapt_CS%adaptAlphaP
          endif
        else if (CS%adapt_CS%adaptAlphaP >= 0.) then
          weight2 = CS%adapt_CS%adaptAlphaP
          weight = 1.0 - CS%adapt_CS%adaptAlphaP
        endif

        dz_i(I,j) = dz_i(I,j) * weight
        dz_p_i(I,j) = dz_p_i(I,j) * weight2

        ! combining density and pressure fluxes
        ! and re-apply limiter XXX check sign
        dz_i(I,j) = dz_i(I,j) + dz_p_i(I,j)
#if 0
        if (dz_i(I,j) < 0.) then
          ! negative flux -- left down, right up
          dz_i(I,j) = max(dz_i(I,j), -0.25 * min(h(i,j,k), h(i+1,j,k-1)))
        else
          ! positive flux -- left up, right down
          dz_i(I,j) = min(dz_i(I,j), 0.25 * min(h(i,j,k-1), h(i+1,j,k)))
        end if
#endif
      end do
    end do

    ! v-points -- these are calculated regardless of the symmetric memory setting
    ! -- we need to calculate the flux at the left and right of our domain
    ! G%jsc-1:G%jec+1 -- so we need an extra point on the left
    do J = G%jsc-2,G%jec+1
      do i = G%isc-1,G%iec+1
        dz_p_j(i,J) = 0.0

        hdi_sig_v = 0.25 * ((hdi_sig(I,j,K)**2 + hdi_sig(I-1,j+1,K)**2) + &
             (hdi_sig(I,j+1,K)**2 + hdi_sig(I-1,j,K)**2))

        j_denom = sqrt(hdj_sig(i,J,K)**2 + hdi_sig_v + &
             0.5 * (dk_sig_int(i,j)**2 + dk_sig_int(i,j+1)**2))
        if (j_denom == 0.) then
          dz_j(i,J) = 0.
        else
          dz_j(i,J) = hdj_sig(i,J,K) / j_denom
        end if

        if (do_diag .and. associated(diag_CS%slope_v)) diag_CS%slope_v(i,J,K) = dz_j(i,J)
        ! dz_j beforehand is unitless (ratio of densities)
        dz_j(i,J) = -dz_j(i,J) * G%dyCv(i,J)**2 * dt / CS%adapt_CS%adaptKappa
        ! dz_j is now [m2]
        if (do_diag .and. associated(diag_CS%denom_v)) diag_CS%denom_v(i,J,K) = j_denom / (h_on_j(i,J,K) + GV%H_subroundoff)

        ! density limiter
        ! dz_j [m2]
        if (dz_j(i,J) < 0.) then
          ! hdj_sig positive -- left down, right up
          dz_j(i,J) = max(dz_j(i,J), -0.125 * min( &
               h(i,j,k) * G%areaT(i,j), &
               h(i,j+1,k-1) * G%areaT(i,j+1)) * G%IdxCv(i,J))
        else
          ! hdj_sig negative -- left up, right down
          dz_j(i,J) = min(dz_j(i,J), 0.125 * min( &
               h(i,j,k-1) * G%areaT(i,j), &
               h(i,j+1,k) * G%areaT(i,j+1)) * G%IdxCv(i,J))
        end if

        dz_p_j(i,J) = 0.5 * (z_int(i,j+1,K) - z_int(i,j,K))

        if (dz_p_j(i,J) > 0.) then
          dz_p_j(i,J) = min(dz_p_j(i,J), 0.25 * min(h(i,j,k-1), h(i,j+1,k)))
        else
          dz_p_j(i,J) = max(dz_p_j(i,J), -0.25 * min(h(i,j,k), h(i,j+1,k-1)))
        end if

        tmpi = 0. ; tmpj = 0. ; tmpk = 0.
        if (tmpi + tmpj + tmpk == 0.) then
          j_denom = 0.0
        else
          j_denom = 1.0 / (tmpi + tmpj + tmpk)
        endif

        weight = tmpk * j_denom
        weight2 = (tmpi + tmpj) * j_denom
        if (do_diag .and. associated(diag_CS%dens_weight_v)) diag_CS%dens_weight_v(i,J,K) = weight
        if (do_diag .and. associated(diag_CS%pres_weight_v)) diag_CS%pres_weight_v(i,J,K) = weight2

#ifdef __DO_SAFETY_CHECKS__
        if (weight > 1. .or. weight2 > 1.) call MOM_error(FATAL, 'build_grid_adaptive: Weight greater than 1')
        if (weight < 0. .or. weight2 < 0.) call MOM_error(FATAL, 'build_grid_adaptive: Negative weight')

        if (weight + weight2 /= 0.0 .and. abs(1. - (weight + weight2)) > 1e-6) then
          write (tmp_char,*) 'sum of weights: ', weight + weight2
          call MOM_error(WARNING, tmp_char)
          call MOM_error(FATAL, 'build_grid_adaptive: Weights do not sum to 1')
        endif
#endif

        if (CS%adapt_CS%adaptAlphaRho >= 0.) then
          weight = CS%adapt_CS%adaptAlphaRho

          if (CS%adapt_CS%adaptAlphaP < 0.) then
            weight2 = 1.0 - CS%adapt_CS%adaptAlphaRho
          else
            weight2 = CS%adapt_CS%adaptAlphaP
          endif
        else if (CS%adapt_CS%adaptAlphaP >= 0.) then
          weight2 = CS%adapt_CS%adaptAlphaP
          weight = 1.0 - CS%adapt_CS%adaptAlphaP
        endif

        dz_j(i,J) = dz_j(i,J) * weight
        dz_p_j(i,J) = dz_p_j(i,J) * weight2

        dz_j(i,J) = dz_j(i,J) + dz_p_j(i,J)
#if 0
        if (dz_j(i,J) < 0.) then
          ! negative flux -- left down, right up
          dz_j(i,J) = max(dz_j(i,J), -0.125 * min(h(i,j,k), h(i,j+1,k-1)))
        else
          ! positive flux -- left up, right down
          dz_j(i,J) = min(dz_j(i,J), 0.125 * min(h(i,j,k-1), h(i,j+1,k)))
        end if
#endif
      end do
    end do

    do j = G%jsc-1,G%jec+1
      do i = G%isc-1,G%iec+1
        if (G%bathyT(i,j) < 0.5) cycle
        ! prior to this point, dz_a and dz_p should be limited such that they
        ! can't cause any tangling. however, they may still lead to some grid-scale
        ! checkerboarding, so we reduce by another factor of 2
        ! 1 - 1e-5 -- make parameter
        dz_a(i,j,K) = 0.5 * G%IareaT(i,j) &
             * ((G%dyCu(I,j) * dz_i(I,j) - G%dyCu(I-1,j) * dz_i(I-1,j)) &
             + (G%dxCv(i,J) * dz_j(i,J) - G%dxCv(i,J-1) * dz_j(i,J-1)))

#if 0
        if (dz_a(i,j,K) < 0.) then
          ! adaptive term says interface should move upward
          if (abs(dz_a(i,j,K)) > 0.5*h(i,j,k-1)) then
            write (tmp_char,*) 'dz_a', dz_a(i,j,K), '0.5*h', 0.5*h(i,j,k-1)
            call MOM_error(WARNING, tmp_char)
            call MOM_error(FATAL, 'build_grid_adaptive: Upward-moving interface by density uses more than 0.5*h')
          endif
        else
          ! interface should move downward
          if (abs(dz_a(i,j,K)) > 0.5*h(i,j,k)) then
            write (tmp_char,*) 'dz_a', dz_a(i,j,K), '0.5*h', 0.5*h(i,j,k)
            call MOM_error(WARNING, tmp_char)
            call MOM_error(FATAL, 'build_grid_adaptive: Downward-moving interface by density uses more than 0.5*h')
          endif
        endif
#endif
      end do
    end do
  end do

  do j = G%jsc-1,G%jec+1
    do i = G%isc-1,G%iec+1
      dzInterface(i,j,:) = 0.
      ! for land points, leave interfaces undisturbed
      if (G%bathyT(i,j) < 0.5) cycle

      z_old(:) = z_int(i,j,:)
      z_new(:) = z_int(i,j,:) + dz_a(i,j,:)

      ! z_new(:) = -(z_old(:) + dz_a(i,j,:) + dz_p(i,j,:))
      ! call build_zstar_column(CS%adapt_CS%zlike_CS, nz, G%bathyT(i,j), &
      !      z_old(nz+1), z_tgt)

      !! restoring term
      ! ! filter between adaptive grid and static grid
      ! call filtered_grid_motion(CS, nz, z_new, z_tgt, dzInterface(i,j,:))
      ! ! apply adaptive interface changes on top
      ! dzInterface(i,j,:) = dzInterface(i,j,:) - dz_a(i,j,:) - dz_p(i,j,:)

      !! restoring term disabled
      call filtered_grid_motion(CS, nz, z_old, z_new, dzInterface(i,j,:))
      dzInterface(i,j,:) = -dzInterface(i,j,:) ! flip signs

      ! using filtered_grid_motion to obtain our dzInterface leads to a loss of precision:
      ! we effectively add the depth of the ocean and immediately subtract it out, losing
      ! about 4-5 orders of magnitude!
      dzInterface(i,j,:) = dz_a(i,j,:)

#ifdef __DO_SAFETY_CHECKS__
      !call check_grid_column(nz, G%bathyT(i,j), h(i,j,:), dzInterface(i,j,:), 'before adjust_interface_motion', i, j, is_fatal=.false.)
#endif

      dzInterfacePrev(:) = dzInterface(i,j,:)
      !call adjust_interface_motion(nz, CS%min_thickness, h(i,j,:), dzInterface(i,j,:))

#ifdef __DO_SAFETY_CHECKS__
      call check_grid_column(nz, G%bathyT(i,j), h(i,j,:), dzInterface(i,j,:), 'after adjust_interface_motion', i, j, dzInterfacePrev)

      if (dzInterface(i,j,1) /= 0.) call MOM_error(FATAL, 'build_grid_adaptive: Surface moved')
      if (dzInterface(i,j,nz+1) /= 0.) call MOM_error(FATAL, 'build_grid_adaptive: Bottom moved')

      ! do K = 2,nz
      !   if (z_new(K) < z_new(K-1)) then
      !     write (tmp_char,*) 'build_grid_adaptive: Interior interfaces cross', &
      !          z_new(K), z_new(K-1)
      !     call MOM_error(FATAL, tmp_char)
      !   endif
      ! enddo

      total_thickness = 0.0
      do k = 1,nz
        total_thickness = total_thickness + h(i,j,k)
      enddo

      dh = max(G%bathyT(i,j), total_thickness)
      ! not sure why this is tripping now...
      ! if (abs(z_new(1) + z_old(1)) > (nz-1)*0.5*epsilon(dh)*dh) then
      !   print *, 'z_new(1)', z_new(1), 'z_old(1)', z_old(1)
      !   stop 'build_grid_adaptive: Top surface has moved'
      ! endif
#endif

    enddo
  enddo
end subroutine build_grid_adaptive

!> Builds a grid that tracks density interfaces for water that is denser than
!! the surface density plus an increment of some number of layers, and uses all
!! lighter layers uniformly above this location.  Note that this amounts to
!! interpolating to find the depth of an arbitrary (non-integer) interface index
!! which should make the results vary smoothly in space to the extent that the
!! surface density and interior stratification vary smoothly in space.  Over
!! shallow topography, this will tend to give a uniform sigma-like coordinate.
!! For sufficiently shallow water, a minimum grid spacing is used to avoid
!! certain instabilities.
subroutine build_grid_SLight( G, GV, h, tv, dzInterface, CS )
  type(ocean_grid_type),                       intent(in)    :: G  !< Grid structure
  type(verticalGrid_type),                     intent(in)    :: GV !< Ocean vertical grid structure
  real, dimension(SZI_(G),SZJ_(G),SZK_(GV)),   intent(in)    :: h  !< Existing model thickness, in H units
  type(thermo_var_ptrs),                       intent(in)    :: tv !< Thermodynamics structure
  real, dimension(SZI_(G),SZJ_(G),SZK_(GV)+1), intent(inout) :: dzInterface !< Changes in interface position
  type(regridding_CS),                         intent(in)    :: CS !< Regridding control structure

  real, dimension(SZK_(GV)+1) :: z_col, z_col_new ! Interface positions relative to the surface in H units (m or kg m-2)
  real, dimension(SZK_(GV)+1) :: dz_col  ! The realized change in z_col in H units (m or kg m-2)
  real, dimension(SZK_(GV))   :: p_col   ! Layer pressure in Pa
  real :: depth
  integer :: i, j, k, nz
  real :: h_neglect, h_neglect_edge

  !### Try replacing both of these with GV%H_subroundoff
  if (GV%Boussinesq) then
    h_neglect = GV%m_to_H*1.0e-30 ; h_neglect_edge = GV%m_to_H*1.0e-10
  else
    h_neglect = GV%kg_m2_to_H*1.0e-30 ; h_neglect_edge = GV%kg_m2_to_H*1.0e-10
  endif

  nz = GV%ke

  if (.not.CS%target_density_set) call MOM_error(FATAL, "build_grid_SLight : "//&
        "Target densities must be set before build_grid_SLight is called.")

  ! Build grid based on target interface densities
  do j = G%jsc-1,G%jec+1 ; do i = G%isc-1,G%iec+1
    if (G%mask2dT(i,j)>0.) then

      depth = G%bathyT(i,j) * GV%m_to_H
      z_col(1) = 0. ! Work downward rather than bottom up
      do K=1,nz
        z_col(K+1) = z_col(K) + h(i, j, k) ! Work in units of h (m or Pa)
        p_col(k) = CS%ref_pressure + CS%compressibility_fraction * &
                    ( 0.5 * ( z_col(K) + z_col(K+1) ) * GV%H_to_Pa - CS%ref_pressure )
      enddo

      call build_slight_column(CS%slight_CS, tv%eqn_of_state, GV%H_to_Pa, GV%m_to_H, &
                          GV%H_subroundoff, nz, depth, h(i, j, :), &
                          tv%T(i, j, :), tv%S(i, j, :), p_col, z_col, z_col_new, &
                          h_neglect=h_neglect, h_neglect_edge=h_neglect_edge)

      ! Calculate the final change in grid position after blending new and old grids
      call filtered_grid_motion( CS, nz, z_col, z_col_new, dz_col )
      do K=1,nz+1 ; dzInterface(i,j,K) = -dz_col(K) ; enddo
#ifdef __DO_SAFETY_CHECKS__
      if (dzInterface(i,j,1) /= 0.) stop 'build_grid_SLight: Surface moved?!'
      if (dzInterface(i,j,nz+1) /= 0.) stop 'build_grid_SLight: Bottom moved?!'
#endif

      ! This adjusts things robust to round-off errors
      call adjust_interface_motion( nz, CS%min_thickness, h(i,j,:), dzInterface(i,j,:) )

    else ! on land
      dzInterface(i,j,:) = 0.
    endif ! mask2dT
  enddo; enddo ! i,j

end subroutine build_grid_SLight

!> Adjust dz_Interface to ensure non-negative future thicknesses
subroutine adjust_interface_motion( nk, min_thickness, h_old, dz_int )
  integer,               intent(in)    :: nk !< Number of layers
  real,                  intent(in)    :: min_thickness !< Minium allowed thickness of h (H units)
  real, dimension(nk),   intent(in)    :: h_old !< Minium allowed thickness of h (H units)
  real, dimension(nk+1), intent(inout) :: dz_int !< Minium allowed thickness of h (H units)
  ! Local variables
  integer :: k
  real :: h_new, eps, h_total, h_err

  eps = 1. ; eps = epsilon(eps)

  h_total = 0. ; h_err = 0.
  do k = 1, nk
    h_total = h_total + h_old(k)
    h_err = h_err + max( h_old(k), abs(dz_int(k)), abs(dz_int(k+1)) )*eps
    h_new = h_old(k) + ( dz_int(k) - dz_int(k+1) )
    if (h_new < -3.0*h_err) then
      write(0,*) 'h<0 at k=',k,'h_old=',h_old(k), &
        'wup=',dz_int(k),'wdn=',dz_int(k+1),'dw_dz=',dz_int(k) - dz_int(k+1), &
        'h_new=',h_new,'h_err=',h_err
      call MOM_error( FATAL, 'MOM_regridding: adjust_interface_motion() - '//&
                     'implied h<0 is larger than roundoff!')
    endif
  enddo
  do k = nk,2,-1
    h_new = h_old(k) + ( dz_int(k) - dz_int(k+1) )
    if (h_new<min_thickness) dz_int(k) = ( dz_int(k+1) - h_old(k) ) + min_thickness ! Implies next h_new = min_thickness
    h_new = h_old(k) + ( dz_int(k) - dz_int(k+1) )
    if (h_new<0.) dz_int(k) = ( 1. - eps ) * ( dz_int(k+1) - h_old(k) ) ! Backup in case min_thickness==0
    h_new = h_old(k) + ( dz_int(k) - dz_int(k+1) )
    if (h_new<0.) then
      write(0,*) 'h<0 at k=',k,'h_old=',h_old(k), &
        'wup=',dz_int(k),'wdn=',dz_int(k+1),'dw_dz=',dz_int(k) - dz_int(k+1), &
        'h_new=',h_new
      stop 'Still did not work!'
      call MOM_error( FATAL, 'MOM_regridding: adjust_interface_motion() - '//&
                     'Repeated adjustment for roundoff h<0 failed!')
    endif
  enddo
 !if (dz_int(1)/=0.) stop 'MOM_regridding: adjust_interface_motion() surface moved'

end subroutine adjust_interface_motion

!------------------------------------------------------------------------------
! Build arbitrary grid
!------------------------------------------------------------------------------
subroutine build_grid_arbitrary( G, GV, h, dzInterface, h_new, CS )
!------------------------------------------------------------------------------
! This routine builds a grid based on arbitrary rules
!------------------------------------------------------------------------------

  ! Arguments
  type(ocean_grid_type),                        intent(in)    :: G  !< Ocean grid structure
  type(verticalGrid_type),                      intent(in)    :: GV !< Ocean vertical grid structure
  real, dimension(SZI_(G),SZJ_(G), SZK_(GV)),   intent(in)    :: h  !< Original ayer thicknesses, in H
  real, dimension(SZI_(G),SZJ_(G), SZK_(GV)+1), intent(inout) :: dzInterface !< The change in interface depth in H
  real,                                         intent(inout) :: h_new !< New layer thicknesses, in H
  type(regridding_CS),                          intent(in)    :: CS !< Regridding control structure

  ! Local variables
  integer   :: i, j, k
  integer   :: nz
  real      :: z_inter(SZK_(GV)+1)
  real      :: total_height
  real      :: delta_h
  real      :: max_depth
  real      :: min_thickness
  real      :: eta              ! local elevation
  real      :: local_depth
  real      :: x1, y1, x2, y2
  real      :: x, t

  nz = GV%ke

  max_depth = G%max_depth
  min_thickness = CS%min_thickness

  do j = G%jsc-1,G%jec+1
    do i = G%isc-1,G%iec+1

      ! Local depth
      local_depth = G%bathyT(i,j)*GV%m_to_H

      ! Determine water column height
      total_height = 0.0
      do k = 1,nz
        total_height = total_height + h(i,j,k)
      end do

      eta = total_height - local_depth

      ! Compute new thicknesses based on stretched water column
      delta_h = (max_depth + eta) / nz

      ! Define interfaces
      z_inter(1) = eta
      do k = 1,nz
        z_inter(k+1) = z_inter(k) - delta_h
      end do

      ! Refine grid in the middle
      do k = 1,nz+1
        x1 = 0.35; y1 = 0.45; x2 = 0.65; y2 = 0.55

        x = - ( z_inter(k) - eta ) / max_depth

        if ( x <= x1 ) then
          t = y1*x/x1
        else if ( (x > x1 ) .and. ( x < x2 )) then
          t = y1 + (y2-y1) * (x-x1) / (x2-x1)
        else
          t = y2 + (1.0-y2) * (x-x2) / (1.0-x2)
        end if

        z_inter(k) = -t * max_depth + eta

      end do

      ! Modify interface heights to account for topography
      z_inter(nz+1) = - local_depth

      ! Modify interface heights to avoid layers of zero thicknesses
      do k = nz,1,-1
        if ( z_inter(k) < (z_inter(k+1) + min_thickness) ) then
          z_inter(k) = z_inter(k+1) + min_thickness
        end if
      end do

      ! Chnage in interface position
      x = 0. ! Left boundary at x=0
      dzInterface(i,j,1) = 0.
      do k = 2,nz
        x = x + h(i,j,k)
        dzInterface(i,j,k) = z_inter(k) - x
      end do
      dzInterface(i,j,nz+1) = 0.

    end do
  end do

stop 'OOOOOOPS' ! For some reason the gnu compiler will not let me delete this
                ! routine????

end subroutine build_grid_arbitrary



!------------------------------------------------------------------------------
! Check grid integrity
!------------------------------------------------------------------------------
subroutine inflate_vanished_layers_old( CS, G, GV, h )
!------------------------------------------------------------------------------
! This routine is called when initializing the regridding options. The
! objective is to make sure all layers are at least as thick as the minimum
! thickness allowed for regridding purposes (this parameter is set in the
! MOM_input file or defaulted to 1.0e-3). When layers are too thin, they
! are inflated up to the minmum thickness.
!------------------------------------------------------------------------------

  ! Arguments
  type(regridding_CS),                    intent(in)    :: CS
  type(ocean_grid_type),                  intent(in)    :: G    !< The ocean's grid structure
  type(verticalGrid_type),                intent(in)    :: GV   !< The ocean's vertical grid structure
  real, dimension(SZI_(G),SZJ_(G), SZK_(GV)), intent(inout) :: h    !< Layer thicknesses, in H (usually m or kg m-2)

  ! Local variables
  integer :: i, j, k
  real    :: hTmp(GV%ke)

  do i = G%isc-1,G%iec+1
    do j = G%jsc-1,G%jec+1

      ! Build grid for current column
      do k = 1,GV%ke
        hTmp(k) = h(i,j,k)
      end do

      call old_inflate_layers_1d( CS%min_thickness, GV%ke, hTmp )

      ! Save modified grid
      do k = 1,GV%ke
        h(i,j,k) = hTmp(k)
      end do

    end do
  end do

end subroutine inflate_vanished_layers_old

!------------------------------------------------------------------------------
! Convective adjustment by swapping layers
!------------------------------------------------------------------------------
subroutine convective_adjustment(G, GV, h, tv)
!------------------------------------------------------------------------------
! Check each water column to see whether it is stratified. If not, sort the
! layers by successive swappings of water masses (bubble sort algorithm)
!------------------------------------------------------------------------------

  ! Arguments
  type(ocean_grid_type), intent(in)                  :: G    !< The ocean's grid structure
  type(verticalGrid_type), intent(in)                :: GV   !< The ocean's vertical grid structure
  real, dimension(SZI_(G),SZJ_(G),SZK_(GV)), intent(inout) :: h    !< Layer thicknesses, in H (usually m or kg m-2)
  type(thermo_var_ptrs), intent(inout)               :: tv   !< A structure pointing to various thermodynamic variables

  ! Local variables
  integer   :: i, j, k
  real      :: T0, T1       ! temperatures
  real      :: S0, S1       ! salinities
  real      :: r0, r1       ! densities
  real      :: h0, h1
  logical   :: stratified
  real, dimension(GV%ke) :: p_col, densities

  p_col(:) = 0.

  ! Loop on columns
  do j = G%jsc-1,G%jec+1 ; do i = G%isc-1,G%iec+1

    ! Compute densities within current water column
    call calculate_density( tv%T(i,j,:), tv%S(i,j,:), p_col, &
                            densities, 1, GV%ke, tv%eqn_of_state )

    ! Repeat restratification until complete
    do
      stratified = .true.
      do k = 1,GV%ke-1
        ! Gather information of current and next cells
        T0 = tv%T(i,j,k)  ; T1 = tv%T(i,j,k+1)
        S0 = tv%S(i,j,k)  ; S1 = tv%S(i,j,k+1)
        r0 = densities(k) ; r1 = densities(k+1)
        h0 = h(i,j,k) ; h1 = h(i,j,k+1)
        ! If the density of the current cell is larger than the density
        ! below it, we swap the cells and recalculate the densitiies
        ! within the swapped cells
        if ( r0 > r1 ) then
          tv%T(i,j,k) = T1 ; tv%T(i,j,k+1) = T0
          tv%S(i,j,k) = S1 ; tv%S(i,j,k+1) = S0
          h(i,j,k)    = h1 ; h(i,j,k+1)    = h0
          ! Recompute densities at levels k and k+1
          call calculate_density( tv%T(i,j,k), tv%S(i,j,k), p_col(k), &
                                  densities(k), tv%eqn_of_state )
          call calculate_density( tv%T(i,j,k+1), tv%S(i,j,k+1), p_col(k+1), &
                                  densities(k+1), tv%eqn_of_state )
          stratified = .false.
        end if
      enddo  ! k

      if ( stratified ) exit
    enddo

  enddo ; enddo  ! i & j

end subroutine convective_adjustment


!------------------------------------------------------------------------------
! Return uniform resolution vector based on coordiante mode
!------------------------------------------------------------------------------
function uniformResolution(nk,coordMode,maxDepth,rhoLight,rhoHeavy)
!------------------------------------------------------------------------------
! Calculate a vector of uniform resolution in the units of the coordinate
!------------------------------------------------------------------------------
  ! Arguments
  integer,          intent(in) :: nk
  character(len=*), intent(in) :: coordMode
  real,             intent(in) :: maxDepth, rhoLight, rhoHeavy
  real                         :: uniformResolution(nk)

  ! Local variables
  integer :: scheme

  scheme = coordinateMode(coordMode)
  select case ( scheme )

    case ( REGRIDDING_ZSTAR, REGRIDDING_HYCOM1, REGRIDDING_SLIGHT, REGRIDDING_SIGMA_SHELF_ZSTAR, &
           REGRIDDING_ADAPTIVE )
      uniformResolution(:) = maxDepth / real(nk)

    case ( REGRIDDING_RHO )
      uniformResolution(:) = (rhoHeavy - rhoLight) / real(nk)

    case ( REGRIDDING_SIGMA )
      uniformResolution(:) = 1. / real(nk)

    case default
      call MOM_error(FATAL, "MOM_regridding, uniformResolution: "//&
       "Unrecognized choice for coordinate mode ("//trim(coordMode)//").")

  end select ! type of grid

end function uniformResolution

subroutine initCoord(CS, coord_mode)
  type(regridding_CS), intent(inout) :: CS
  character(len=*),    intent(in)    :: coord_mode

  select case (coordinateMode(coord_mode))
  case (REGRIDDING_ZSTAR)
    call init_coord_zlike(CS%zlike_CS, CS%nk, CS%coordinateResolution)
  case (REGRIDDING_SIGMA_SHELF_ZSTAR)
    call init_coord_zlike(CS%zlike_CS, CS%nk, CS%coordinateResolution)
  case (REGRIDDING_SIGMA)
    call init_coord_sigma(CS%sigma_CS, CS%nk, CS%coordinateResolution)
  case (REGRIDDING_RHO)
    call init_coord_rho(CS%rho_CS, CS%nk, CS%ref_pressure, CS%target_density, CS%interp_CS)
  case (REGRIDDING_HYCOM1)
    call init_coord_hycom(CS%hycom_CS, CS%nk, CS%coordinateResolution, CS%target_density, CS%interp_CS)
  case (REGRIDDING_SLIGHT)
    call init_coord_slight(CS%slight_CS, CS%nk, CS%ref_pressure, CS%target_density, CS%interp_CS)
  case (REGRIDDING_ADAPTIVE)
    call init_coord_adapt(CS%adapt_CS, CS%nk, CS%coordinateResolution)
  end select
end subroutine initCoord

!------------------------------------------------------------------------------
! Set the fixed resolution data
!------------------------------------------------------------------------------
subroutine setCoordinateResolution( dz, CS )
  real, dimension(:),  intent(in)    :: dz
  type(regridding_CS), intent(inout) :: CS

  if (size(dz)/=CS%nk) call MOM_error( FATAL, &
      'setCoordinateResolution: inconsistent number of levels' )

  CS%coordinateResolution(:) = dz(:)

end subroutine setCoordinateResolution

!> Set target densities based on the old Rlay variable
subroutine set_target_densities_from_GV( GV, CS )
  type(verticalGrid_type), intent(in)    :: GV !< Ocean vertical grid structure
  type(regridding_CS),     intent(inout) :: CS !< Regridding control structure
  ! Local variables
  integer :: k, nz

  nz = CS%nk
  CS%target_density(1)    = GV%Rlay(1)+0.5*(GV%Rlay(1)-GV%Rlay(2))
  CS%target_density(nz+1) = GV%Rlay(nz)+0.5*(GV%Rlay(nz)-GV%Rlay(nz-1))
  do k = 2,nz
    CS%target_density(k) = CS%target_density(k-1) + CS%coordinateResolution(k)
  end do
  CS%target_density_set = .true.

end subroutine set_target_densities_from_GV

!> Set target densities based on vector of interface values
subroutine set_target_densities( CS, rho_int )
  type(regridding_CS),      intent(inout) :: CS !< Regridding control structure
  real, dimension(CS%nk+1), intent(in)    :: rho_int !< Interface densities

  if (size(CS%target_density)/=size(rho_int)) then
    call MOM_error(FATAL, "set_target_densities inconsistent args!")
  endif

  CS%target_density(:) = rho_int(:)
  CS%target_density_set = .true.

end subroutine set_target_densities

!> Set maximum interface depths based on a vector of input values.
subroutine set_regrid_max_depths( CS, max_depths, units_to_H )
  type(regridding_CS),      intent(inout) :: CS !< Regridding control structure
  real, dimension(CS%nk+1), intent(in)    :: max_depths !< Maximum interface depths, in arbitrary units
  real, optional,           intent(in)    :: units_to_H !< A conversion factor for max_depths into H units
  ! Local variables
  real :: val_to_H
  integer :: K

  if (.not.allocated(CS%max_interface_depths)) allocate(CS%max_interface_depths(1:CS%nk+1))

  val_to_H = 1.0 ; if (present( units_to_H)) val_to_H = units_to_H
  if (max_depths(CS%nk+1) < max_depths(1)) val_to_H = -1.0*val_to_H

  ! Check for sign reversals in the depths.
  if (max_depths(CS%nk+1) < max_depths(1)) then
    do K=1,CS%nk ; if (max_depths(K+1) > max_depths(K)) &
      call MOM_error(FATAL, "Unordered list of maximum depths sent to set_regrid_max_depths!")
    enddo
  else
    do K=1,CS%nk ; if (max_depths(K+1) < max_depths(K)) &
      call MOM_error(FATAL, "Unordered list of maximum depths sent to set_regrid_max_depths.")
    enddo
  endif

  do K=1,CS%nk+1
    CS%max_interface_depths(K) = val_to_H * max_depths(K)
  enddo

  ! set max depths for coordinate
  select case (CS%regridding_scheme)
  case (REGRIDDING_HYCOM1)
    call set_hycom_params(CS%hycom_CS, max_interface_depths=CS%max_interface_depths)
  case (REGRIDDING_SLIGHT)
    call set_slight_params(CS%slight_CS, max_interface_depths=CS%max_interface_depths)
  end select
end subroutine set_regrid_max_depths

!> Set maximum layer thicknesses based on a vector of input values.
subroutine set_regrid_max_thickness( CS, max_h, units_to_H )
  type(regridding_CS),      intent(inout) :: CS !< Regridding control structure
  real, dimension(CS%nk+1), intent(in)    :: max_h !< Maximum interface depths, in arbitrary units
  real, optional,           intent(in)    :: units_to_H !< A conversion factor for max_h into H units
  ! Local variables
  real :: val_to_H
  integer :: K

  if (.not.allocated(CS%max_layer_thickness)) allocate(CS%max_layer_thickness(1:CS%nk))

  val_to_H = 1.0 ; if (present( units_to_H)) val_to_H = units_to_H

  do k=1,CS%nk
    CS%max_layer_thickness(k) = val_to_H * max_h(k)
  enddo

  ! set max thickness for coordinate
  select case (CS%regridding_scheme)
  case (REGRIDDING_HYCOM1)
    call set_hycom_params(CS%hycom_CS, max_layer_thickness=CS%max_layer_thickness)
  case (REGRIDDING_SLIGHT)
    call set_slight_params(CS%slight_CS, max_layer_thickness=CS%max_layer_thickness)
  end select
end subroutine set_regrid_max_thickness


!------------------------------------------------------------------------------
! Query the fixed resolution data
!------------------------------------------------------------------------------
function getCoordinateResolution( CS )
  type(regridding_CS), intent(in) :: CS
  real, dimension(CS%nk)          :: getCoordinateResolution

  getCoordinateResolution(:) = CS%coordinateResolution(:)

end function getCoordinateResolution

!> Query the target coordinate interface positions
function getCoordinateInterfaces( CS )
  type(regridding_CS), intent(in) :: CS                      !< Regridding control structure
  real, dimension(CS%nk+1)        :: getCoordinateInterfaces !< Interface positions in target coordinate

  integer :: k

  ! When using a coordinate with target densities, we need to get the actual
  ! densities, rather than computing the interfaces based on resolution
  if (CS%regridding_scheme == REGRIDDING_RHO) then
    if (.not. CS%target_density_set) &
      call MOM_error(FATAL, 'MOM_regridding, getCoordinateInterfaces: '//&
                            'target densities not set!')

    getCoordinateInterfaces(:) = CS%target_density(:)
  else
    getCoordinateInterfaces(1) = 0.
    do k = 1, CS%nk
      getCoordinateInterfaces(k+1) = getCoordinateInterfaces(k) &
                                    -CS%coordinateResolution(k)
    enddo
    ! The following line has an "abs()" to allow ferret users to reference
    ! data by index. It is a temporary work around...  :(  -AJA
    getCoordinateInterfaces(:) = abs( getCoordinateInterfaces(:) )
  end if

end function getCoordinateInterfaces

!------------------------------------------------------------------------------
! Query the target coordinate units
!------------------------------------------------------------------------------
function getCoordinateUnits( CS )
  type(regridding_CS), intent(in) :: CS
  character(len=20)               :: getCoordinateUnits

  select case ( CS%regridding_scheme )
    case ( REGRIDDING_ZSTAR, REGRIDDING_HYCOM1, REGRIDDING_SLIGHT, REGRIDDING_ADAPTIVE )
      getCoordinateUnits = 'meter'
    case ( REGRIDDING_SIGMA_SHELF_ZSTAR )
      getCoordinateUnits = 'meter/fraction'
    case ( REGRIDDING_SIGMA )
      getCoordinateUnits = 'fraction'
    case ( REGRIDDING_RHO )
      getCoordinateUnits = 'kg/m3'
    case ( REGRIDDING_ARBITRARY )
      getCoordinateUnits = 'unknown'
    case default
      call MOM_error(FATAL,'MOM_regridding, getCoordinateUnits: '//&
                     'Unknown regridding scheme selected!')
  end select ! type of grid

end function getCoordinateUnits

!------------------------------------------------------------------------------
! Query the short name of the coordinate
!------------------------------------------------------------------------------
function getCoordinateShortName( CS )
  type(regridding_CS), intent(in) :: CS
  character(len=20)               :: getCoordinateShortName

  select case ( CS%regridding_scheme )
    case ( REGRIDDING_ZSTAR )
      !getCoordinateShortName = 'z*'
      ! The following line is a temporary work around...  :(  -AJA
      getCoordinateShortName = 'pseudo-depth, -z*'
    case ( REGRIDDING_SIGMA_SHELF_ZSTAR )
      getCoordinateShortName = 'pseudo-depth, -z*/sigma'
    case ( REGRIDDING_SIGMA )
      getCoordinateShortName = 'sigma'
    case ( REGRIDDING_RHO )
      getCoordinateShortName = 'rho'
    case ( REGRIDDING_ARBITRARY )
      getCoordinateShortName = 'coordinate'
    case ( REGRIDDING_HYCOM1 )
      getCoordinateShortName = 'z-rho'
    case ( REGRIDDING_SLIGHT )
      getCoordinateShortName = 's-rho'
    case ( REGRIDDING_ADAPTIVE )
      getCoordinateShortName = 'adaptive'
    case default
      call MOM_error(FATAL,'MOM_regridding, getCoordinateShortName: '//&
                     'Unknown regridding scheme selected!')
  end select ! type of grid

end function getCoordinateShortName

!> Can be used to set any of the parameters for MOM_regridding.
subroutine set_regrid_params( CS, boundary_extrapolation, min_thickness, old_grid_weight, &
             interp_scheme, depth_of_time_filter_shallow, depth_of_time_filter_deep, &
             compress_fraction, dz_min_surface, nz_fixed_surface, Rho_ML_avg_depth, &
             nlay_ML_to_interior, fix_haloclines, halocline_filt_len, &
             halocline_strat_tol, integrate_downward_for_e, &
             adaptAlphaRho, adaptAlphaP, adaptKappa, adaptTau, adaptMean)
  type(regridding_CS), intent(inout) :: CS !< Regridding control structure
  logical, optional, intent(in) :: boundary_extrapolation !< Extrapolate in boundary cells
  real,    optional, intent(in) :: min_thickness !< Minimum thickness allowed when building the new grid (m)
  real,    optional, intent(in) :: old_grid_weight !< Weight given to old coordinate when time-filtering grid
  character(len=*), optional, intent(in) :: interp_scheme !< Interpolation method for state-dependent coordinates
  real,    optional, intent(in) :: depth_of_time_filter_shallow !< Depth to start cubic (H units)
  real,    optional, intent(in) :: depth_of_time_filter_deep !< Depth to end cubic (H units)
  real,    optional, intent(in) :: compress_fraction !< Fraction of compressibility to add to potential density
  real,    optional, intent(in) :: dz_min_surface !< The fixed resolution in the topmost SLight_nkml_min layers (m)
  integer, optional, intent(in) :: nz_fixed_surface !< The number of fixed-thickess layers at the top of the model
  real,    optional, intent(in) :: Rho_ml_avg_depth !< Averaging depth over which to determine mixed layer potential density (m)
  real,    optional, intent(in) :: nlay_ML_to_interior !< Number of layers to offset the mixed layer density to find resolved stratification (nondim)
  logical, optional, intent(in) :: fix_haloclines !< Detect regions with much weaker stratification in the coordinate
  real,    optional, intent(in) :: halocline_filt_len !< Length scale over which to filter T & S when looking for spuriously unstable water mass profiles (m)
  real,    optional, intent(in) :: halocline_strat_tol !< Value of the stratification ratio that defines a problematic halocline region.
  logical, optional, intent(in) :: integrate_downward_for_e !< If true, integrate for interface positions downward from the top.
  real, optional, intent(in) :: adaptAlphaRho, adaptAlphaP, adaptKappa, adaptTau
  logical, optional, intent(in) :: adaptMean

  if (present(interp_scheme)) call set_interp_scheme(CS%interp_CS, interp_scheme)
  if (present(boundary_extrapolation)) call set_interp_extrap(CS%interp_CS, boundary_extrapolation)

  if (present(old_grid_weight)) then
    if (old_grid_weight<0. .or. old_grid_weight>1.) &
      call MOM_error(FATAL,'MOM_regridding, set_regrid_params: Weight is out side the range 0..1!')
    CS%old_grid_weight = old_grid_weight
  endif
  if (present(depth_of_time_filter_shallow)) CS%depth_of_time_filter_shallow = depth_of_time_filter_shallow
  if (present(depth_of_time_filter_deep)) CS%depth_of_time_filter_deep = depth_of_time_filter_deep
  if (present(depth_of_time_filter_shallow) .or. present(depth_of_time_filter_deep)) then
    if (CS%depth_of_time_filter_deep<CS%depth_of_time_filter_shallow) call MOM_error(FATAL,'MOM_regridding, '//&
                     'set_regrid_params: depth_of_time_filter_deep<depth_of_time_filter_shallow!')
  endif

  if (present(min_thickness)) CS%min_thickness = min_thickness
  if (present(compress_fraction)) CS%compressibility_fraction = compress_fraction
  if (present(integrate_downward_for_e)) CS%integrate_downward_for_e = integrate_downward_for_e

  select case (CS%regridding_scheme)
  case (REGRIDDING_ZSTAR)
    if (present(min_thickness)) call set_zlike_params(CS%zlike_CS, min_thickness=min_thickness)
  case (REGRIDDING_SIGMA_SHELF_ZSTAR)
    if (present(min_thickness)) call set_zlike_params(CS%zlike_CS, min_thickness=min_thickness)
  case (REGRIDDING_SIGMA)
    if (present(min_thickness)) call set_sigma_params(CS%sigma_CS, min_thickness=min_thickness)
  case (REGRIDDING_RHO)
    if (present(min_thickness)) call set_rho_params(CS%rho_CS, min_thickness=min_thickness)
    if (present(integrate_downward_for_e)) call set_rho_params(CS%rho_CS, integrate_downward_for_e=integrate_downward_for_e)
    if (associated(CS%rho_CS) .and. (present(interp_scheme) .or. present(boundary_extrapolation))) &
      call set_rho_params(CS%rho_CS, interp_CS=CS%interp_CS)
  case (REGRIDDING_HYCOM1)
    if (associated(CS%hycom_CS) .and. (present(interp_scheme) .or. present(boundary_extrapolation))) &
      call set_hycom_params(CS%hycom_CS, interp_CS=CS%interp_CS)
  case (REGRIDDING_SLIGHT)
    if (present(min_thickness))       call set_slight_params(CS%slight_CS, min_thickness=min_thickness)
    if (present(dz_min_surface))      call set_slight_params(CS%slight_CS, dz_ml_min=dz_min_surface)
    if (present(nz_fixed_surface))    call set_slight_params(CS%slight_CS, nz_fixed_surface=nz_fixed_surface)
    if (present(Rho_ML_avg_depth))    call set_slight_params(CS%slight_CS, Rho_ML_avg_depth=Rho_ML_avg_depth)
    if (present(nlay_ML_to_interior)) call set_slight_params(CS%slight_CS, nlay_ML_offset=nlay_ML_to_interior)
    if (present(fix_haloclines))      call set_slight_params(CS%slight_CS, fix_haloclines=fix_haloclines)
    if (present(halocline_filt_len))  call set_slight_params(CS%slight_CS, halocline_filter_length=halocline_filt_len)
    if (present(halocline_strat_tol)) call set_slight_params(CS%slight_CS, halocline_strat_tol=halocline_strat_tol)
    if (present(compress_fraction))   call set_slight_params(CS%slight_CS, compressibility_fraction=compress_fraction)
    if (associated(CS%slight_CS) .and. (present(interp_scheme) .or. present(boundary_extrapolation))) &
      call set_slight_params(CS%slight_CS, interp_CS=CS%interp_CS)
  case (REGRIDDING_ADAPTIVE)
    if (associated(CS%adapt_CS)) &
         call set_adapt_params(CS%adapt_CS, adaptAlphaRho=adaptAlphaRho, adaptAlphaP=adaptAlphaP, &
         adaptKappa=adaptKappa, adaptTau=adaptTau, adaptMean=adaptMean)
  end select

end subroutine set_regrid_params

!> Returns the number of levels/layers in the regridding control structure
integer function get_regrid_size(CS)
  type(regridding_CS), intent(inout) :: CS !< Regridding control structure

  get_regrid_size = CS%nk

end function get_regrid_size

function get_zlike_CS(CS)
  type(regridding_CS), intent(in) :: CS
  type(zlike_CS) :: get_zlike_CS

  get_zlike_CS = CS%zlike_CS
end function get_zlike_CS

function get_sigma_CS(CS)
  type(regridding_CS), intent(in) :: CS
  type(sigma_CS) :: get_sigma_CS

  get_sigma_CS = CS%sigma_CS
end function get_sigma_CS

function get_rho_CS(CS)
  type(regridding_CS), intent(in) :: CS
  type(rho_CS) :: get_rho_CS

  get_rho_CS = CS%rho_CS
end function get_rho_CS

!------------------------------------------------------------------------------
! Return coordinate-derived thicknesses for fixed coordinate systems
!------------------------------------------------------------------------------
function getStaticThickness( CS, SSH, depth )
  type(regridding_CS), intent(in) :: CS
  real,                intent(in) :: SSH
  real,                intent(in) :: depth
  real, dimension(CS%nk)          :: getStaticThickness
  ! Local
  integer :: k
  real :: z, dz

  select case ( CS%regridding_scheme )
    case ( REGRIDDING_ZSTAR, REGRIDDING_SIGMA_SHELF_ZSTAR, REGRIDDING_HYCOM1, REGRIDDING_SLIGHT, REGRIDDING_ADAPTIVE )
      if (depth>0.) then
        z = ssh
        do k = 1, CS%nk
          dz = CS%coordinateResolution(k) * ( 1. + ssh/depth ) ! Nominal dz*
          dz = max(dz, 0.)                                     ! Avoid negative incase ssh=-depth
          dz = min(dz, depth - z)                              ! Clip if below topography
          z = z + dz                                           ! Bottom of layer
          getStaticThickness(k) = dz
        enddo
      else
        getStaticThickness(:) = 0. ! On land ...
      endif
    case ( REGRIDDING_SIGMA )
      getStaticThickness(:) = CS%coordinateResolution(:) * ( depth + ssh )
    case ( REGRIDDING_RHO )
      getStaticThickness(:) = 0. ! Not applicable
    case ( REGRIDDING_ARBITRARY )
      getStaticThickness(:) = 0.  ! Not applicable
    case default
      call MOM_error(FATAL,'MOM_regridding, getStaticThickness: '//&
                     'Unknown regridding scheme selected!')
  end select ! type of grid

end function getStaticThickness

!> Parses a string and generates a dz(:) profile that goes like k**power.
subroutine dz_function1( string, dz )
  character(len=*),   intent(in)    :: string !< String with list of parameters in form
                                              !! dz_min, H_total, power, precision
  real, dimension(:), intent(inout) :: dz     !< Profile of nominal thicknesses
  ! Local variables
  integer :: nk, k
  real    :: dz_min, power, prec, H_total

  nk = size(dz) ! Number of cells
  prec = -1024.
  read( string, *) dz_min, H_total, power, prec
  if (prec == -1024.) call MOM_error(FATAL,"dz_function1: "// &
          "Problem reading FNC1: string  ="//trim(string))
  ! Create profile of ( dz - dz_min )
  do k = 1, nk
    dz(k) = (real(k-1)/real(nk-1))**power
  enddo
  dz(:) = ( H_total - real(nk) * dz_min ) * ( dz(:) / sum(dz) ) ! Rescale to so total is H_total
  dz(:) = anint( dz(:) / prec ) * prec ! Rounds to precision prec
  dz(:) = ( H_total - real(nk) * dz_min ) * ( dz(:) / sum(dz) ) ! Rescale to so total is H_total
  dz(:) = anint( dz(:) / prec ) * prec ! Rounds to precision prec
  dz(nk) = dz(nk) + ( H_total - sum( dz(:) + dz_min ) ) ! Adjust bottommost layer
  dz(:) = anint( dz(:) / prec ) * prec ! Rounds to precision prec
  dz(:) = dz(:) + dz_min ! Finally add in the constant dz_min

end subroutine dz_function1

!> Parses a string and generates a rho_target(:) profile with refined resolution downward
!! and returns the number of levels
integer function rho_function1( string, rho_target )
  character(len=*),   intent(in)    :: string !< String with list of parameters in form
                                              !! dz_min, H_total, power, precision
  real, dimension(:), allocatable, intent(inout) :: rho_target !< Profile of interface densities
  ! Local variables
  integer :: nki, k, nk
  real    :: ddx, dx, rho_1, rho_2, rho_3, drho, rho_4, drho_min

  read( string, *) nk, rho_1, rho_2, rho_3, drho, rho_4, drho_min
  allocate(rho_target(nk+1))
  nki = nk + 1 - 4 ! Number of interfaces minus 4 specified values
  rho_target(1) = rho_1
  rho_target(2) = rho_2
  dx = 0.
  do k = 0, nki
    ddx = max( drho_min, real(nki-k)/real(nki*nki) )
    dx = dx + ddx
    rho_target(3+k) = rho_3 + (2. * drho) * dx
  enddo
  rho_target(nki+4) = rho_4

  rho_function1 = nk

end function rho_function1

!> \namespace mom_regridding
!!
!! A vertical grid is defined solely by the cell thicknesses, \f$h\f$.
!! Most calculations in this module start with the coordinate at the bottom
!! of the column set to -depth, and use a increasing value of coordinate with
!! decreasing k. This is consistent with the rest of MOM6 that uses position,
!! \f$z\f$ which is a negative quantity for most of the ocean.
!!
!! A change in grid is define through a change in position of the interfaces:
!! \f[
!! z^n_{k+1/2} = z^{n-1}_{k+1/2} + \Delta z_{k+1/2}
!! \f]
!! with the positive upward coordinate convention
!! \f[
!! z_{k-1/2} = z_{k+1/2} + h_k
!! \f]
!! so that
!! \f[
!! h^n_k = h^{n-1}_k + ( \Delta z_{k-1/2} - \Delta z_{k+1/2} )
!! \f]
!!
!! Original date of creation: 2008.06.09 by L. White

end module MOM_regridding
